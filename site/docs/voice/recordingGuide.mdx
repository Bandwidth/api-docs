---
id: recordingGuide
title: Recording
slug: /voice/guides/recording
description: How to record using Bandwidth's Voice API
keywords:
  - bandwidth
  - voice
  - recording
  - transcription
hide_title: false
image: ../../static/img/bandwidth-logo.png
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide will show how to do call recording via the [Record](/docs/voice/bxml/record) and [StartRecording](/docs/voice/bxml/startRecording) verbs, and produce a transcription of those recordings.
You can record any inbound or outbound call and request transcription of the call after completion using our API. Please ensure you have followed our earlier guide on [how to make an outbound call](/docs/voice/guides/outboundCall) with Bandwidth.

There are two ways you can record a call; with `<Record>` or with `<StartRecording>`. Both have their own use case this guide will go over.

#### Use `<Record>` if:

* You're capturing a voicemail
* You only need a single party recording
* You're capturing input that should pause the call until finished

#### Use `<StartRecording>` if:

* You want to record both ends (together or separate) of a phone call
* You want to record a call for quality assurance
* You need other BXML verbs to execute while a recording is going on

### Record

The Record verb starts recording in a call and pauses all BXML execution until the recording is terminated by a timeout (`maxDuration`) or a terminating digit (`terminatingDigits`). Once the recording ends, BXML execution will continue at the next verb, or at the BXML at the `recordCompleteUrl` if this attribute is set.

If the `recordingAvailableUrl` attribute is set, this URL will receive a callback once the recording is available to use.

#### Record Example

<Tabs
  groupId="bxml"
  defaultValue="xml"
  values={[
    { label: 'XML', value: 'xml', },
    { label: 'Java', value: 'java', },
    { label: 'C#', value: 'csharp', },
    { label: 'Ruby', value: 'ruby', },
    { label: 'NodeJS', value: 'nodejs', },
    { label: 'Python', value: 'python', },
    { label: 'PHP', value: 'php', },
  ]
}>
<TabItem value="xml">

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <SpeakSentence>Please say your name.</SpeakSentence>
    <Record recordCompleteUrl="https://myapp.test/nextBXML" maxDuration="5"/>
    <!-- Any verbs after this point would be replaced by those returned by the recordCompleteUrl -->
</Response>
```

</TabItem>
<TabItem value="java">

```java
SpeakSentence speakSentence = SpeakSentence.builder()
    .text("Please say your name.")
    .build();

Record record = Record.builder()
    .recordCompleteUrl("/nextBXML")
    .recordingAvailableUrl("https://myapp.com/recordingAvailable")
    .maxDuration(5)
    .build();

Response response = Response.builder().build()
    .add(speakSentence)
    .add(record);

return bxml;
```

</TabItem>
<TabItem value="csharp">

```csharp
SpeakSentence speakSentence = new SpeakSentence
{
    Sentence = "Please say your name."
};

Record record = new Record
{
    RecordCompleteUrl = "/nextBXML",
    RecordingAvailableUrl = "https://myapp.com/recordingAvailable",
    MaxDuration = 5
};

Response response = new Response();
response.Add(speakSentence);
response.Add(record);

return new OkObjectResult(response.ToBXML());
```

</TabItem>
<TabItem value="ruby">

```ruby
speak_sentence = Bandwidth::Voice::SpeakSentence.new({
    :sentence => "Please say your name."
})

record = Bandwidth::Voice::Record.new({
    :record_complete_url => "/nextBXML",
    :recording_available_url => "https://myapp.com/recordingAvailable",
    :max_duration => "5"
})

response = Bandwidth::Voice::Response.new()
response.push(speak_sentence)
response.push(record)

return response.to_bxml()
```

</TabItem>
<TabItem value="nodejs">

```js
const speakSentence = new SpeakSentence({
    sentence: "Please say your name."
});

const record = new Record({
    recordCompleteUrl: "https://myapp.com/nextBXML",
    recordingAvailableUrl: "https://myapp.com/recordingAvailable",
    maxDuration: 10
});

const response = new Response(speakSentence, record);

console.log(response.toBxml());
```

</TabItem>
<TabItem value="python">

```python
    speak_sentence = SpeakSentence(
    sentence="Please say your name.",
)

record = Record(
    record_complete_url="https://myapp.com/nextBXML",
    recording_available_url="https://myapp.com/recordingAvailable",
    max_duration=5
)

response = Response()
response.add_verb(speak_sentence)
response.add_verb(play_audio)
response.add_verb(record)

print(response.to_bxml())
```

</TabItem>
<TabItem value="php">

```php

$speakSentence = new BandwidthLib\Voice\Bxml\SpeakSentence("Please say your name.");

$record = new BandwidthLib\Voice\Bxml\Record();
$record->recordCompleteUrl("https://myapp.com/nextBXML");
$record->recordingAvailableUrl("https://myapp.com/recordingAvailable");
$record->maxDuration(5);

$response = new BandwidthLib\Voice\Bxml\Response();
$response->addVerb($speakSentence);
$response->addVerb($record);

echo $response->toBxml();
```

</TabItem>
</Tabs>

### StartRecording

The StartRecording verb starts recording in a call without pausing BXML execution. The [PauseRecording](/docs/voice/bxml/pauseRecording), [ResumeRecording](/docs/voice/bxml/resumeRecording), and [StopRecording](/docs/voice/bxml/stopRecording) BXML verbs can be used to toggle the recording. Recording is terminated by either the call ending, or by a StopRecording verb.

Much like the Record verb, StartRecording also has a `recordingAvailableUrl` attribute to receive the recording available callback.

<Tabs
  groupId="bxml"
  defaultValue="xml"
  values={[
    { label: 'XML', value: 'xml', },
    { label: 'Java', value: 'java', },
    { label: 'C#', value: 'csharp', },
    { label: 'Ruby', value: 'ruby', },
    { label: 'NodeJS', value: 'nodejs', },
    { label: 'Python', value: 'python', },
    { label: 'PHP', value: 'php', },
  ]
}>
<TabItem value="xml">

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <SpeakSentence>Please say your name.</SpeakSentence>
    <Record recordCompleteUrl="https://myapp.test/nextBXML" maxDuration="5"/>
    <!-- Any verbs after this point would be replaced by those returned by the recordCompleteUrl -->
</Response>
```

</TabItem>
<TabItem value="java">

```java
@Post /answerCall endpoint
public String recordName() {
    SpeakSentence speakSentence = SpeakSentence.builder()
        .text("Please say your name.")
        .build();

    Record record = Record.builder()
        .recordCompleteUrl("/nextBXML")
        .recordingAvailableUrl("https://myapp.com/recordingAvailable")
        .maxDuration(5)
        .build();

    Response response = Response.builder().build()
        .add(speakSentence)
        .add(record);

    return bxml;
}

@Post /nextBxml endpoint
public byte[] getAudio() {
    SpeakSentence speakSentence = SpeakSentence.builder()
        .text("Thank you for saying your name. Goodbye!")
        .build();
    Hangup hangup = Hangup.builder().build();

    Response response = Response.builder().build()
        .add(speakSentence)
        .add(hangup);

    return bxml;


}
```

</TabItem>
<TabItem value="csharp">

```csharp
SpeakSentence speakSentence = new SpeakSentence
{
    Sentence = "Please say your name."
};

Record record = new Record
{
    RecordCompleteUrl = "https://myapp.com/nextBXML",
    RecordingAvailableUrl = "https://myapp.com/recordingAvailable",
    MaxDuration = 5
};

Response response = new Response();
response.Add(speakSentence);
response.Add(record);

Console.WriteLine(response.ToBXML());
```

</TabItem>
<TabItem value="ruby">

```ruby
speak_sentence = Bandwidth::Voice::SpeakSentence.new({
    :sentence => "Please say your name."
})

record = Bandwidth::Voice::Record.new({
    :record_complete_url => "https://myapp.com/nextBXML",
    :recording_available_url => "https://myapp.com/recordingAvailable",
    :max_duration => "5"
})

response = Bandwidth::Voice::Response.new()
response.push(speak_sentence)
response.push(record)

puts response.to_bxml()
```

</TabItem>
<TabItem value="nodejs">

```js
const speakSentence = new SpeakSentence({
    sentence: "Please say your name."
});

const record = new Record({
    recordCompleteUrl: "https://myapp.com/nextBXML",
    recordingAvailableUrl: "https://myapp.com/recordingAvailable",
    maxDuration: 10
});

const response = new Response(speakSentence, record);

console.log(response.toBxml());
```

</TabItem>
<TabItem value="python">

```python
speak_sentence = SpeakSentence(
    sentence="Please say your name.",
)

record = Record(
    record_complete_url="https://myapp.com/nextBXML",
    recording_available_url="https://myapp.com/recordingAvailable",
    max_duration=5
)

response = Response()
response.add_verb(speak_sentence)
response.add_verb(play_audio)
response.add_verb(record)

print(response.to_bxml())
```

</TabItem>
<TabItem value="php">

```php
$speakSentence = new BandwidthLib\Voice\Bxml\SpeakSentence("Please say your name.");

$record = new BandwidthLib\Voice\Bxml\Record();
$record->recordCompleteUrl("https://myapp.com/nextBXML");
$record->recordingAvailableUrl("https://myapp.com/recordingAvailable");
$record->maxDuration(5);

$response = new BandwidthLib\Voice\Bxml\Response();
$response->addVerb($speakSentence);
$response->addVerb($record);

echo $response->toBxml();
```

</TabItem>
</Tabs>

##### StartRecording Used With StopRecording, PauseRecording, and ResumeRecording

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <StartRecording recordingAvailableUrl="https://myapp.com/noBXML"/>
    <SpeakSentence voice="bridget">Recording is active while this sentence is being spoken.</SpeakSentence>
    <PauseRecording/>
    <SpeakSentence voice="bridget">Recording has been paused.</SpeakSentence>
    <ResumeRecording/>
    <SpeakSentence voice="bridget">Recording has been resumed and is active while this sentence is being spoken.</SpeakSentence>
    <StopRecording/>
    <SpeakSentence voice="bridget">Recording has been stopped.</SpeakSentence>
</Response>
```

### Download Recording

After the call has completed you can retrieve information on the recording and download the file in .mp3 or .wav format. Recordings are stored for 30 days.

<Tabs
    groupId="bxml"
    defaultValue="xml"
    values={[
        { label: 'cURL', value: 'curl', },
        { label: 'Java', value: 'java', },
        { label: 'C#', value: 'csharp', },
        { label: 'Ruby', value: 'ruby', },
        { label: 'NodeJS', value: 'nodejs', },
        { label: 'Python', value: 'python', },
        { label: 'PHP', value: 'php', },
    ]
}>
<TabItem value="curl">

```curl
curl 'https://voice.bandwidth.com/api/v2/accounts/$BW_ACCOUNT_ID/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41' \
    -U {BANDWIDTH_USERNAME}:{BANDWIDTH:PASSWORD}
```

</TabItem>
<TabItem value="java">

```java
import com.bandwidth.BandwidthClient;
import com.bandwidth.http.response.ApiResponse;
import com.bandwidth.voice.models.CallRecordingMetadata;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Sample {
    public static final String USERNAME = System.getenv("BW_USERNAME");
    public static final String PASSWORD = System.getenv("BW_PASSWORD");
    public static final String ACCOUNT_ID = System.getenv("BW_ACCOUNT_ID");

    public static void main(String[] args) {
        // Call id is returned after successfully creating a call.
        String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
        // Recording id is returned after retrieving a recording from the call.
        String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

        BandwidthClient client = new BandwidthClient.Builder()
                .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                .build();

        try {
            CompletableFuture<ApiResponse<CallRecordingMetadata>> completableFuture = client.getVoiceClient().getAPIController().getCallRecordingAsync(ACCOUNT_ID, callId, recordingId);
            System.out.println(completableFuture.get().getResult());
        } catch (InterruptedException | ExecutionException e) {
            System.out.println(e.getMessage());
        }
    }
}

```

</TabItem>
<TabItem value="csharp">

```csharp
using System;
using System.Threading.Tasks;
using Bandwidth.Standard;
using Bandwidth.Standard.Exceptions;
using Bandwidth.Standard.Voice.Models;

class Program
{
    static async Task Main(string[] args)
    {
        var username = System.Environment.GetEnvironmentVariable("BW_USERNAME");
        var password = System.Environment.GetEnvironmentVariable("BW_PASSWORD");
        var accountId = System.Environment.GetEnvironmentVariable("BW_ACCOUNT_ID");

        // Call id is returned after successfully creating a call.
        var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
        // Recording id is returned after retrieving a recording from the call.
        var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

        var client = new BandwidthClient.Builder()
            .VoiceBasicAuthCredentials(username, password)
            .Build();

        try
        {
            var response = await client.Voice.APIController.GetCallRecordingAsync(accountId, callId, recordingId);
            Console.WriteLine(response.Data);
        }
        catch (ApiException e)
        {
            Console.WriteLine(e.Message);
        }
    }
}

```

</TabItem>
<TabItem value="ruby">

```ruby
require 'bandwidth'

include Bandwidth
include Bandwidth::Voice

bandwidth_client = Bandwidth::Client.new(
    voice_basic_auth_user_name: ENV['BW_USERNAME'],
    voice_basic_auth_password: ENV['BW_PASSWORD']
)

voice_client = bandwidth_client.voice_client.client

call_id = "c-1234"
recording_id = "r-1234"

begin
    response = voice_client.get_call_recording(ENV['BW_ACCOUNT_ID'], call_id, recording_id)
    puts response.data.application_id
rescue APIException => e
    puts e.response_code
end

```

</TabItem>
<TabItem value="nodejs">

```js
import { Client, ApiController } from '@bandwidth/voice';

const BW_USERNAME = process.env["BW_USERNAME"];
const BW_PASSWORD = process.env["BW_PASSWORD"];
const BW_ACCOUNT_ID = process.env["BW_ACCOUNT_ID"];

const client = new Client({
  basicAuthUserName: BW_USERNAME,
  basicAuthPassword: BW_PASSWORD
});

const controller = new ApiController(client);

const accountId = BW_ACCOUNT_ID;

const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

const getCallRecording = async function() {
  try {
      const response = await controller.getCallRecording(accountId, callId, recordingId);
      console.log(response)
  } catch(error) {
      console.error(error);
  }
}

getCallRecording();

```

</TabItem>
<TabItem value="python">

```python
from bandwidth.bandwidth_client import BandwidthClient
from bandwidth.exceptions.api_exception import APIException

import os

BW_USERNAME = os.environ["BW_USERNAME"]
BW_PASSWORD = os.environ["BW_PASSWORD"]
BW_ACCOUNT_ID = os.environ["BW_ACCOUNT_ID"]

bandwidth_client = BandwidthClient(
    voice_basic_auth_user_name=BW_USERNAME,
    voice_basic_auth_password=BW_PASSWORD
)
voice_client = bandwidth_client.voice_client.client

call_id = "c-1234"
recording_id = "r-1234"

try:
    response = voice_client.get_call_recording(BW_ACCOUNT_ID, call_id, recording_id)
    print(response.body.application_id)
except APIException as e:
    print(e.response_code)

```

</TabItem>
<TabItem value="php">

```php

require "vendor/autoload.php";

$BW_USERNAME = getenv("BW_USERNAME");
$BW_PASSWORD = getenv("BW_PASSWORD");
$BW_ACCOUNT_ID = getenv("BW_ACCOUNT_ID");

$config = new BandwidthLib\Configuration(
    array(
        'voiceBasicAuthUserName' => $BW_USERNAME,
        'voiceBasicAuthPassword' => $BW_PASSWORD,
    )
);
$client = new BandwidthLib\BandwidthClient($config);

$voiceClient = $client->getVoice()->getClient();

$callId = "c-1234";
$recordingId = "r-1234";

try {
    $response = $voiceClient->getCallRecording($BW_ACCOUNT_ID, $callId, $recordingId);
    print_r($response->getResult()->applicationId);
} catch (BandwidthLib\APIException $e) {
    print_r($e->getResponseCode());
}
```

</TabItem>
</Tabs>


### Initiate Transcription

The transcribe attribute can be added to the Record or StartRecording BXML verbs. You can also choose to request transcription of a recording after it has been completed via the API.

If you want to receive a TranscriptionAvailable callback, you can additionally set the transcriptionAvailableUrl to a URL on your callback server and transcriptionAvailableMethod to its associated HTTP method (GET or POST, the default).

:::tip
Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.
:::

### Recording Transcription Example

<Tabs
    groupId="bxml"
    defaultValue="xml"
    values={[
        { label: 'cURL', value: 'curl', },
        { label: 'Java', value: 'java', },
        { label: 'C#', value: 'csharp', },
        { label: 'Ruby', value: 'ruby', },
        { label: 'NodeJS', value: 'nodejs', },
        { label: 'Python', value: 'python', },
        { label: 'PHP', value: 'php', },
    ]
}>
<TabItem value="curl">

    ```curl
    curl 'https://voice.bandwidth.com/api/v2/accounts/$BW_ACCOUNT_ID/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41' \
    -U {BANDWIDTH_USERNAME}:{BANDWIDTH:PASSWORD}
    ```

</TabItem>
<TabItem value="java">

    ```java


    ```

</TabItem>
<TabItem value="csharp">

    ```csharp


    ```

</TabItem>
<TabItem value="ruby">

    ```ruby


    ```

</TabItem>
<TabItem value="nodejs">

    ```js


    ```

</TabItem>
<TabItem value="python">

    ```python


    ```

</TabItem>
<TabItem value="php">

    ```php


    ```

</TabItem>
</Tabs>

### Download Transcription

After the call has completed, you can download the transcribed file in JSON format. Transcriptions are stored for 30 days.

<Tabs
    groupId="bxml"
    defaultValue="xml"
    values={[
        { label: 'cURL', value: 'curl', },
        { label: 'Java', value: 'java', },
        { label: 'C#', value: 'csharp', },
        { label: 'Ruby', value: 'ruby', },
        { label: 'NodeJS', value: 'nodejs', },
        { label: 'Python', value: 'python', },
        { label: 'PHP', value: 'php', },
    ]
}>
<TabItem value="curl">

    ```curl
    curl 'https://voice.bandwidth.com/api/v2/accounts/$BW_ACCOUNT_ID/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41' \
    -U {BANDWIDTH_USERNAME}:{BANDWIDTH:PASSWORD}
    ```

</TabItem>
<TabItem value="java">

    ```java


    ```

</TabItem>
<TabItem value="csharp">

    ```csharp


    ```

</TabItem>
<TabItem value="ruby">

    ```ruby


    ```

</TabItem>
<TabItem value="nodejs">

    ```js


    ```

</TabItem>
<TabItem value="python">

    ```python


    ```

</TabItem>
<TabItem value="php">

    ```php


    ```

</TabItem>
</Tabs>


### Where to next?

Now that you have learnt how to record and transcribe calls, check out some of the available actions in the following guides:
- [How to gather user input (IVR)](/docs/voice/guides/interactiveVoiceResponse)
- [How to use voicemail detection](/docs/voice/guides/machineDetection)
- [How to create conference calls](/docs/voice/guides/conference)
