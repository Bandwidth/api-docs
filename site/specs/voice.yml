openapi: 3.0.3
info:
  title: Voice
  version: 4.1.0
  contact:
    name: Bandwidth
    url: https://support.bandwidth.com
    email: support@bandwidth.com
  description: |-
    The API Specification for Bandwidth's Programmable Voice Platform

    ## Base URL

    `https://voice.bandwidth.com/api/v2`
servers:
  - url: https://voice.bandwidth.com/api/v2
    description: Production
paths:
  /accounts/{accountId}/calls:
    post:
      tags:
        - Calls
      summary: Create Call
      description: >-
        Creates an outbound phone call.


        All calls are initially queued. Your outbound calls will initiated at a
        specific dequeueing rate, enabling your application to "fire and forget"
        when creating calls. Queued calls may not be modified until they are
        dequeued and placed, but may be removed from your queue on demand.


        <b>Please note:</b> Calls submitted to your queue will be placed
        approximately in order, but exact ordering is not guaranteed.
      operationId: createCall
      parameters:
        - $ref: '#/components/parameters/accountId'
      requestBody:
        $ref: '#/components/requestBodies/createCallRequest'
      responses:
        '201':
          $ref: '#/components/responses/createCallResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: |
            curl 'https://voice.bandwidth.com/api/v2/accounts/12345/calls' \
                -X POST \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "from": "+15554443333",
                    "to": "+15553334444, sip:john@doe.com",
                    "uui": "eyJhbGciOiJIUzI1NiJ9.WyJoaSJd.-znkjYyCkgz4djmHUPSXl9YrJ6Nix_XvmlwKGFh5ERM;encoding=jwt,aGVsbG8gd29ybGQ=;encoding=base64",
                    "callTimeout": 0,
                    "callbackTimeout": 0,
                    "answerUrl": "http://example.com",
                    "answerFallbackUrl": "http://example.com",
                    "username": "string",
                    "password": "string",
                    "fallbackUsername": "string",
                    "fallbackPassword": "string",
                    "answerMethod": "POST",
                    "answerFallbackMethod": "POST",
                    "disconnectUrl": "http://example.com",
                    "disconnectMethod": "POST",
                    "tag": "string",
                    "applicationId": "string",
                    "machineDetection": {
                        "mode": "sync",
                        "detectionTimeout": 0,
                        "silenceTimeout": 0,
                        "speechThreshold": 0,
                        "speechEndThreshold": 0,
                        "delayResult": true,
                        "callbackUrl": "http://example.com",
                        "callbackMethod": "POST",
                        "fallbackUrl": "http://example.com",
                        "fallbackMethod": "POST",
                        "username": "string",
                        "password": "string",
                        "fallbackUsername": "string",
                        "fallbackPassword": "string"
                    }
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";
                    var applicationId = "1234-qwer";
                    var to = "+15553334444";
                    var from = "+15554443333";
                    var baseUrl = "https://sample.com";
                    var answerUrl = string.Concat(baseUrl, "/callbacks/answer");

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var request = new CreateCallRequest()
                    {
                        ApplicationId = applicationId,
                        To = to,
                        From = from,
                        AnswerUrl = answerUrl
                    };

                    try
                    {
                        var response = await client.Voice.APIController.CreateCallAsync(accountId, request);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.CreateCallRequest;
            import com.bandwidth.voice.models.CreateCallResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String voiceApplicationId = "1234-qwer";
                    String to = "+15553334444";
                    String from = "+15554443333";
                    String baseUrl = "https://sample.com";
                    String answerUrl = baseUrl.concat("/callbacks/answer");

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    CreateCallRequest request = new CreateCallRequest();
                    request.setApplicationId(voiceApplicationId);
                    request.setTo(to);
                    request.setFrom(from);
                    request.setAnswerUrl(answerUrl);

                    try {
                        CompletableFuture<ApiResponse<CreateCallResponse>> completableFuture = client.getVoiceClient().getAPIController().createCallAsync(ACCOUNT_ID, request);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";
            const BW_VOICE_APPLICATION_ID = "1234-qwer";
            const BW_NUMBER = "+15554443333";
            const USER_NUMBER = "+15553334444";
            const VOICE_CALLBACK_URL = process.env["BASE_CALLBACK_URL"];

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const makeCall = async function() {
              try {
                const response = await controller.createCall(accountId, {
                    applicationId: BW_VOICE_APPLICATION_ID,
                    to: USER_NUMBER,
                    from: BW_NUMBER,
                    answerUrl: VOICE_CALLBACK_URL,
                    answerMethod: 'POST',
                    callTimeout: 30
                });
                console.log(response.body);
              } catch(error) {
                  console.error(error);
              }
            }

            makeCall();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";
            1234-qwer = "1234-qwer";
            +15554443333 = "+15554443333";
            +15553334444 = "+15553334444";
            $VOICE_CALLBACK_URL = "https://sample.com";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $body = new BandwidthLib\Voice\Models\CreateCallRequest();
            $body->from = $BW_NUMBER;
            $body->to = $USER_NUMBER;
            $body->answerUrl = $VOICE_CALLBACK_URL;
            $body->applicationId = $BW_VOICE_APPLICATION_ID;

            try {
                $response = $voiceClient->createCall($BW_ACCOUNT_ID, $body);
                print_r($response->getResult()->callId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            } 
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.create_call_request import
            CreateCallRequest

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"

            BW_VOICE_APPLICATION_ID = "1234-qwer"

            BW_NUMBER = "+15554443333"

            USER_NUMBER = "+15553334444"

            VOICE_CALLBACK_URL = https://sample.com


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            body = CreateCallRequest()

            body.application_id = BW_VOICE_APPLICATION_ID

            body.to = USER_NUMBER

            body.mfrom = BW_NUMBER

            body.answer_url = VOICE_CALLBACK_URL

            try:
                response = voice_client.create_call(BW_ACCOUNT_ID, body)
                print(response.body.call_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            body = CreateCallRequest.new
            body.from = "+15554443333"
            body.to = "+15553334444"
            body.answer_url = "http://www.myapp.com/hello"
            body.application_id = "7fc9698a-b04a-468b-9e8f-91238c0d0086"

            begin
                result = voice_client.create_call("12345", body)
                puts result.data.call_id
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}:
    get:
      tags:
        - Calls
      summary: Get Call State Information
      description: >-
        Retrieve the current state of a specific call. This information is
        near-realtime, so it may take a few minutes for your call to be
        accessible using this endpoint.


        **Note**: Call information is kept for 7 days after the calls are hung
        up. If you attempt to retrieve information for a call that is older than
        7 days, you will get an HTTP 404 response.
      operationId: getCallState
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      responses:
        '200':
          $ref: '#/components/responses/getCallStateResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetCallAsync(accountId, callId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.CallState;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<CallState>> completableFuture = client.getVoiceClient().getAPIController().getCallAsync(ACCOUNT_ID, callId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const getCall = async function() {
              try {
                  const response = await controller.getCall(accountId, callId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getCall();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";

            try {
                $response = $voiceClient->getCall($BW_ACCOUNT_ID, $callId);
                print_r($response->getResult()->state);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"

            try:
                result = voice_client.get_call(BW_ACCOUNT_ID, call_id)
                print(result.body.state)
            except APIException as e: 
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"

            begin
                #result = voice_client.get_call("12345", call_id)
                #puts result.data.state
                puts "Method broke"
            rescue APIException => e
                puts e.response_code
            end
    post:
      tags:
        - Calls
      summary: Update Call
      description: >-
        Interrupts and redirects a call to a different URL that should return a
        BXML document.
      operationId: updateCall
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      requestBody:
        $ref: '#/components/requestBodies/updateCallRequest'
      responses:
        '200':
          description: Call Successfully Modified
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '409':
          $ref: '#/components/responses/voiceConflictError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d'
            \
                -X POST \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "state": "active",
                    "redirectUrl": "http://example.com",
                    "redirectFallbackUrl": "http://example.com",
                    "redirectMethod": "POST",
                    "redirectFallbackMethod": "POST",
                    "username": "string",
                    "password": "string",
                    "fallbackUsername": "string",
                    "fallbackPassword": "string",
                    "tag": "string"
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";
                    var applicationId = "1234-qwer";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var request = new ModifyCallRequest()
                    {
                        State = StateEnum.Completed
                    };

                    try
                    {
                        await client.Voice.APIController.ModifyCallAsync(accountId, callId, request);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.ModifyCallRequest;
            import com.bandwidth.voice.models.StateEnum;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    ModifyCallRequest request = new ModifyCallRequest();
                    request.setState(StateEnum.COMPLETED);

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().modifyCallAsync(ACCOUNT_ID, callId, request);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const modifyCall = async function() {
              try {
                  const response = await controller.modifyCall(accountId, callId, {
                    state: "active",
                    redirectUrl: "http://www.myapp.com/new"
                  });
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            modifyCall();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";

            $body = new BandwidthLib\Voice\Models\ModifyCallRequest();
            $body->redirectUrl = "http://www.myapp.com/new";
            $body->state = "active";

            try {
                $voiceClient->modifyCall($BW_ACCOUNT_ID, $callId, $body);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.modify_call_request import
            ModifyCallRequest

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            call_id = "c-1234"


            body = ModifyCallRequest()

            body.redirect_url = "http://www.myapp.com/new"

            body.state = "active"


            try:
                voice_client.modify_call(BW_ACCOUNT_ID, call_id, body)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            body = ModifyCallRequest.new
            body.redirect_url = "http://www.myapp.com/new"
            body.state = "active"

            call_id = "c-1234"

            begin
                voice_client.modify_call("12345", call_id, body)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}/bxml:
    put:
      tags:
        - Calls
      summary: Update Call BXML
      description: Interrupts and replaces an active call's BXML document.
      operationId: updateCallBxml
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      requestBody:
        $ref: '#/components/requestBodies/updateCallBxmlRequest'
      responses:
        '204':
          description: Call BXML Successfully Replaced
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '409':
          $ref: '#/components/responses/voiceConflictError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
  /accounts/{accountId}/conferences:
    get:
      tags:
        - Conferences
      summary: Get Conferences
      description: >-
        Returns a max of 1000 conferences, sorted by `createdTime` from oldest
        to newest.


        **NOTE:** If the number of conferences in the account is bigger than
        `pageSize`, a `Link` header (with format `<{url}>; rel="next"`) will be
        returned in the response. The url can be used to retrieve the next page
        of conference records.
      operationId: listConferences
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/name'
        - $ref: '#/components/parameters/minCreatedTime'
        - $ref: '#/components/parameters/maxCreatedTime'
        - $ref: '#/components/parameters/pageSize'
        - $ref: '#/components/parameters/pageToken'
      responses:
        '200':
          $ref: '#/components/responses/listConferencesResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl 'https://voice.bandwidth.com/api/v2/accounts/12345/conferences'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetConferencesAsync(accountId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.ConferenceState;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;
            import java.util.List;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<List<ConferenceState>>> completableFuture = client.getVoiceClient().getAPIController().getConferencesAsync(ACCOUNT_ID, null, null, null, null, null);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const getConferences = async function() {
              try {
                  const response = await controller.getConferences(accountId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getConferences();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            try {
                $response = $voiceClient->getConferences($BW_ACCOUNT_ID);
                if (count($response->getResult()) > 0) {
                    print_r($response->getResult()[0]->id);
                }
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            try:
                response = voice_client.get_conferences(BW_ACCOUNT_ID)
                if len(response.body) > 0:
                    print(response.body[0].id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            begin
                response = voice_client.get_conferences("12345")
                if response.data.length > 0
                    puts response.data[0].id
                end
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/conferences/{conferenceId}:
    get:
      tags:
        - Conferences
      summary: Get Conference Information
      description: Returns information about the specified conference.
      operationId: getConference
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
      responses:
        '200':
          $ref: '#/components/responses/getConferenceResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetConferenceAsync(accountId, conferenceId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.ConferenceState;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Conference id is returned after successfully creating a conference.
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<ConferenceState>> completableFuture = client.getVoiceClient().getAPIController().getConferenceAsync(ACCOUNT_ID, conferenceId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-abc12345-6defabc1-2345-6def-abc1-23456defabc1';


            const getConference = async function() {
              try {
                  const response = await controller.getConference(accountId, conferenceId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            getConference();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "conf-1234";

            try {
                $response = $voiceClient->getConference($BW_ACCOUNT_ID, $conferenceId);
                print_r($response->getResult()->name);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"

            try:
                response = voice_client.get_conference(BW_ACCOUNT_ID, conference_id)
                print(response.body.name)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"

            begin
                response = voice_client.get_conference("12345", conference_id)
                print(response.data.name)
            rescue APIException => e
                puts e.response_code
            end
    post:
      tags:
        - Conferences
      summary: Update Conference
      description: Update the conference state.
      operationId: updateConference
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
      requestBody:
        $ref: '#/components/requestBodies/updateConferenceRequest'
      responses:
        '204':
          description: Conference successfully modified
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8'
            \
                -X POST \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "status": "active",
                    "redirectUrl": "http://example.com",
                    "redirectFallbackUrl": "http://example.com",
                    "redirectMethod": "POST",
                    "redirectFallbackMethod": "POST",
                    "username": "string",
                    "password": "string",
                    "fallbackUsername": "string",
                    "fallbackPassword": "string"
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var request = new ModifyConferenceRequest
                    {
                        Status = StatusEnum.Completed
                    };

                    try
                    {
                        await client.Voice.APIController.ModifyConferenceAsync(accountId, conferenceId, request);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.*;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    ModifyConferenceRequest request = new ModifyConferenceRequest();
                    request.setStatus(StatusEnum.COMPLETED);

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().modifyConferenceAsync(ACCOUNT_ID, conferenceId, request);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-abc12345-6defabc1-2345-6def-abc1-23456defabc1';


            const modifyConference = async function() {
              try {
                  const response = await controller.modifyConference(accountId, conferenceId, {
                    status: 'active',
                    redirectUrl: 'http://www.myapp.com/new'
                  });
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            modifyConference();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "conf-1234";

            $body = new BandwidthLib\Voice\Models\ModifyConferenceRequest();
            $body->state = "active";

            try {
                $voiceClient->modifyConference($BW_ACCOUNT_ID, $conferenceId, $body);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.modify_conference_request import
            ModifyConferenceRequest

            from bandwidth.voice.models.status_enum import StatusEnum

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            body = ModifyConferenceRequest()

            body.status = StatusEnum.ACTIVE


            conference_id = "conf-1234"


            try:
                voice_client.modify_conference(BW_ACCOUNT_ID, conference_id, body)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            body = ModifyConferenceRequest.new
            body.status = StatusEnum::ACTIVE

            conference_id = "conf-1234"

            begin
                voice_client.modify_conference("12345", conference_id, body)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/conferences/{conferenceId}/bxml:
    put:
      tags:
        - Conferences
      summary: Update Conference BXML
      description: Update the conference BXML document.
      operationId: updateConferenceBxml
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
      requestBody:
        $ref: '#/components/requestBodies/updateConferenceBxmlRequest'
      responses:
        '204':
          description: Conference successfully modified
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
  /accounts/{accountId}/conferences/{conferenceId}/members/{memberId}:
    get:
      tags:
        - Conferences
      summary: Get Conference Member
      description: Returns information about the specified conference member.
      operationId: getConferenceMember
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
        - $ref: '#/components/parameters/memberId'
      responses:
        '200':
          $ref: '#/components/responses/getConferenceMemberResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8/members/c-95ac8d8d-b81437f5-4586-4d5b-9b46-29f8b3fe0aaf'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    var memberId = "c-95ac8d8d-b81437f5-4586-4d5b-9b46-29f8b3fe0aaf";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetConferenceMemberAsync(accountId, conferenceId, memberId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.ConferenceMemberState;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    String memberId = "c-95ac8d8d-b81437f5-4586-4d5b-9b46-29f8b3fe0aaf";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<ConferenceMemberState>> completableFuture = client.getVoiceClient().getAPIController().getConferenceMemberAsync(ACCOUNT_ID, conferenceId, memberId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const memberId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';


            const getConferenceMember = async function() {
              try {
                  const response = await controller.getConferenceMember(accountId, conferenceId, memberId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            getConferenceMember();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "conf-1234";
            $memberId = "m-1234";

            try {
                $response = $voiceClient->getConferenceMember($BW_ACCOUNT_ID, $conferenceId, $memberId);
                print_r($response->getResult()->memberUrl);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            member_id = "m-1234"

            try:
                response = voice_client.get_conference_member(BW_ACCOUNT_ID, conference_id, member_id)
                print(response.body.member_url)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            member_id = "m-1234"

            begin
                response = voice_client.get_conference_member("12345", conference_id, member_id)
                puts response.data.member_url
            rescue APIException => e
                puts e.response_code
            end
    put:
      tags:
        - Conferences
      summary: Update Conference Member
      description: Updates settings for a particular conference member.
      operationId: updateConferenceMember
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
        - $ref: '#/components/parameters/memberId'
      requestBody:
        $ref: '#/components/requestBodies/updateConferenceMemberRequest'
      responses:
        '204':
          description: Conference member successfully modified
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8/members/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d'
            \
                -X PUT \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "callId": "string",
                    "conferenceId": "string",
                    "memberUrl": "string",
                    "mute": true,
                    "hold": true,
                    "callIdsToCoach": [
                        "string"
                    ]
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var detail = new ConferenceMemberState
                    {
                        Mute = true
                    };

                    try
                    {
                        await client.Voice.APIController.ModifyConferenceMemberAsync(accountId, conferenceId, callId, detail);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.*;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    ConferenceMemberState conferenceMemberState = new ConferenceMemberState();
                    conferenceMemberState.setMute(true);

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().modifyConferenceMemberAsync(ACCOUNT_ID, conferenceId, callId, conferenceMemberState);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const memberId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';


            const modifyConferenceMember = async function() {
              try {
                  const response = await controller.modifyConferenceMember(accountId, conferenceId, memberId, {
                    mute: true,
                    callIdsToCoach : ["c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d", "c-2a913f94-6a486f3a-3cae-4034-bcc3-f0c9fa77ca2f"]
                  });
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            modifyConferenceMember();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "conf-1234";
            $callId = "c-1234";

            $body = new BandwidthLib\Voice\Models\ConferenceMemberState();
            $body->mute = true;

            try {
                $voiceClient->modifyConferenceMember($BW_ACCOUNT_ID, $conferenceId, $callId, $body);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.conference_member_state import
            ConferenceMemberState

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            body = ConferenceMemberState()

            body.mute = True


            conference_id = "conf-1234"

            call_id = "c-1234"


            try:
                voice_client.modify_conference_member(BW_ACCOUNT_ID, conference_id, call_id, body)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            body = ConferenceMemberState.new
            body.mute = true

            conference_id = "conf-1234"
            call_id = "c-1234"

            begin
                voice_client.modify_conference_member("12345", conference_id, call_id, body)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/conferences/{conferenceId}/recordings:
    get:
      tags:
        - Conferences
      summary: Get Conference Recordings
      description: >-
        Returns a (potentially empty) list of metadata for the recordings that
        took place during the specified conference.
      operationId: listConferenceRecordings
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
      responses:
        '200':
          $ref: '#/components/responses/listConferenceRecordingsResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8/recordings'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetConferenceRecordingsAsync(accountId, conferenceId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.ConferenceRecordingMetadata;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;
            import java.util.List;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<List<ConferenceRecordingMetadata>>> completableFuture = client.getVoiceClient().getAPIController().getConferenceRecordingsAsync(ACCOUNT_ID, conferenceId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';


            const getConferenceRecordings = async function() {
              try {
                  const response = await controller.getConferenceRecordings(accountId, conferenceId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            getConferenceRecordings();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "c-1234";

            try {
                $response = $voiceClient->getConferenceRecordings($BW_ACCOUNT_ID, $conferenceId);
                if (count($response->getResult()) > 0) {
                    print_r($response->getResult()[0]->name);
                }
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"

            try:
                response = voice_client.get_conference_recordings(BW_ACCOUNT_ID, conference_id)
                if len(response.body) > 0:
                    print(response.body[0].name)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"

            begin
                response = voice_client.get_conference_recordings("12345", conference_id)
                if response.data.length > 0
                    puts response.body[0].name
                end
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/conferences/{conferenceId}/recordings/{recordingId}:
    get:
      tags:
        - Conferences
      summary: Get Conference Recording Information
      description: Returns metadata for the specified recording.
      operationId: getConferenceRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '200':
          $ref: '#/components/responses/getConferenceRecordingResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetConferenceRecordingAsync(accountId, conferenceId, recordingId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.CallRecordingMetadata;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<CallRecordingMetadata>> completableFuture = client.getVoiceClient().getAPIController().getConferenceRecordingAsync(ACCOUNT_ID, conferenceId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';


            const getConferenceRecording = async function() {
              try {
                  const response = await controller.getConferenceRecording(accountId, conferenceId, recordingId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }


            getConferenceRecording();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "c-1234";
            $recordingId = "r-1234";

            try {
                $response = $voiceClient->getConferenceRecording($BW_ACCOUNT_ID, $conferenceId, $recordingId);
                print_r($response->getResult()->applicationId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            recording_id = "r-1234"

            try:
                response = voice_client.get_conference_recording(BW_ACCOUNT_ID, conference_id, recording_id)
                print(response.body.application_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            recording_id = "r-1234"

            begin
                response = voice_client.get_conference_recording("12345", conference_id, recording_id)
                puts response.body.application_id
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/conferences/{conferenceId}/recordings/{recordingId}/media:
    get:
      tags:
        - Conferences
      summary: Download Conference Recording
      description: Downloads the specified recording file.
      operationId: downloadConferenceRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/conferenceId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '200':
          $ref: '#/components/responses/downloadRecordingMediaResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/conferences/conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/media'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetDownloadConferenceRecordingAsync(accountId, conferenceId, recordingId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.DynamicResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Conference id is returned after successfully creating a conference.
                    String conferenceId = "conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<DynamicResponse>> completableFuture = client.getVoiceClient().getAPIController().getDownloadConferenceRecordingAsync(ACCOUNT_ID, conferenceId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: >
            import { Client, ApiController } from '@bandwidth/voice';


            const BW_USERNAME = "api-username";

            const BW_PASSWORD = "api-password";

            const BW_ACCOUNT_ID = "12345";


            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });


            const controller = new ApiController(client);


            const accountId = BW_ACCOUNT_ID;


            const conferenceId =
            'conf-95ac8d8d-28e06798-2afe-434c-b0f4-666a79cd47f8';

            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';


            try {
                const response = await controller.getDownloadConferenceRecording(accountId, conferenceId, recordingId);
                console.log(response);
            } catch (error) {
                console.error(error);
            }
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $conferenceId = "conf-1234";
            $recordingId = "r-1234";

            try {
                $response = $voiceClient->getDownloadConferenceRecording($BW_ACCOUNT_ID, $conferenceId, $recordingId);
                $downloaded_recording = $response->getResult();
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            recording_id = "r-1234"

            try:
                response = voice_client.get_download_conference_recording(BW_ACCOUNT_ID, conference_id, recording_id)
                downloaded_recording = response.body
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: BW_USERNAME,
                voice_basic_auth_password: BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client

            conference_id = "conf-1234"
            recording_id = "r-1234"

            begin
                result = voice_client.get_download_conference_recording(BW_ACCOUNT_ID, conference_id, recording_id)
                downloaded_recording = result.data
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/recordings:
    get:
      tags:
        - Recordings
      summary: Get Call Recordings
      description: >-
        Returns a list of metadata for the recordings associated with the

        specified account. The list can be filtered by the optional from, to,
        minStartTime,

        and maxStartTime arguments. The list is capped at 1000 entries and may
        be

        empty if no recordings match the specified criteria.
      operationId: listAccountCallRecordings
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/to'
        - $ref: '#/components/parameters/from'
        - $ref: '#/components/parameters/minStartTime'
        - $ref: '#/components/parameters/maxStartTime'
      responses:
        '200':
          $ref: '#/components/responses/listCallRecordingsResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl 'https://voice.bandwidth.com/api/v2/accounts/12345/recordings'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetQueryCallRecordingsAsync(accountId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.*;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;
            import java.util.List;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<List<CallRecordingMetadata>>> completableFuture = client.getVoiceClient().getAPIController().getQueryCallRecordingsAsync(ACCOUNT_ID, null, null, null, null);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const getCallRecordings = async function() {
              try {
                  const response = await controller.getQueryCallRecordings(accountId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getCallRecordings();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            try {
                $response = $voiceClient->getQueryCallRecordings($BW_ACCOUNT_ID);
                if (count($response->getResult()) > 0) {
                    print_r($response->getResult()[0]->recordingId);
                }
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            try:
                result = voice_client.get_query_call_recordings(BW_ACCOUNT_ID)
                if len(result.body) > 0:
                    print(result.body[0].recording_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            begin
                result = voice_client.get_query_call_recordings("12345")
                if result.data.length > 0
                    puts result.data[0].recording_id
                end
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}/recording:
    put:
      tags:
        - Recordings
      summary: Update Recording
      description: Pause or resume a recording on an active phone call.
      operationId: updateCallRecordingState
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      requestBody:
        $ref: '#/components/requestBodies/updateCallRecordingRequest'
      responses:
        '200':
          description: Recording state successfully modified
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recording'
            \
                -X PUT \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "state": "NOT_RECORDING",
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var state = new ModifyCallRecordingRequest
                    {
                        State = State1Enum.PAUSED
                    };

                    try
                    {
                        await client.Voice.APIController.ModifyCallRecordingStateAsync(accountId, callId, state);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.*;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    ModifyCallRecordingRequest recordingRequest = new ModifyCallRecordingRequest();
                    recordingRequest.setState(State1Enum.PAUSED);

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().modifyCallRecordingStateAsync(ACCOUNT_ID, callId, recordingRequest);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';

            const modifyCallRecordingState = async function() {
              try {
                  const response = await controller.modifyCallRecordingState(accountId, callId, {
                  state: 'PAUSED'
                });
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            modifyCallRecordingState();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";

            $body = new BandwidthLib\Voice\Models\ModifyCallRecordingRequest();
            $body->redirectUrl = "http://www.myapp.com/new";
            $body->state = "paused";

            try {
                $voiceClient->modifyCallRecordingState($BW_ACCOUNT_ID, $callId, $body);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.modify_call_recording_request import
            ModifyCallRecordingRequest

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            body = ModifyCallRecordingRequest()

            body.state = "paused"


            call_id = "c-1234"


            try:
                voice_client.modify_call_recording_state(BW_ACCOUNT_ID, call_id, body)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            body = ModifyCallRecordingRequest.new
            body.state = "paused"

            call_id = "c-1234"

            begin
                voice_client.modify_call_recording_state("12345", call_id, body)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}/recordings:
    get:
      tags:
        - Recordings
      summary: List Call Recordings
      description: |-
        Returns a (potentially empty) list of metadata for the recordings
        that took place during the specified call.
      operationId: listCallRecordings
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      responses:
        '200':
          $ref: '#/components/responses/listCallRecordingsResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetCallRecordingsAsync(accountId, callId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.CallRecordingMetadata;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;
            import java.util.List;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<List<CallRecordingMetadata>>> completableFuture = client.getVoiceClient().getAPIController().getCallRecordingsAsync(ACCOUNT_ID, callId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const getCallRecordings = async function() {
              try {
                  const response = await controller.getCallRecordings(accountId, callId, recordingId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getCallRecordings();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";

            try {
                $response = $voiceClient->getCallRecordings($BW_ACCOUNT_ID, $callId);
                if (count($response->getResult()) > 0) {
                    print_r($response->getResult()[0]->recordingId);
                }
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"

            try:
                response = voice_client.get_call_recordings(BW_ACCOUNT_ID, call_id)
                if len(response.body) > 0:
                    print(response.body[0].recording_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'

            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"

            begin
                response = voice_client.get_call_recordings("12345", call_id)
                if response.data.length > 0
                    puts response.data[0].media_url
                end
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}/recordings/{recordingId}:
    get:
      tags:
        - Recordings
      summary: Get Call Recording
      description: Returns metadata for the specified recording.
      operationId: getCallRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '200':
          $ref: '#/components/responses/getCallRecordingResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetCallRecordingAsync(accountId, callId, recordingId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.CallRecordingMetadata;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<CallRecordingMetadata>> completableFuture = client.getVoiceClient().getAPIController().getCallRecordingAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const getCallRecording = async function() {
              try {
                  const response = await controller.getCallRecording(accountId, callId, recordingId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getCallRecording();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $response = $voiceClient->getCallRecording($BW_ACCOUNT_ID, $callId, $recordingId);
                print_r($response->getResult()->applicationId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                response = voice_client.get_call_recording(BW_ACCOUNT_ID, call_id, recording_id)
                print(response.body.application_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                response = voice_client.get_call_recording("12345", call_id, recording_id)
                puts response.data.application_id
            rescue APIException => e
                puts e.response_code
            end
    delete:
      tags:
        - Recordings
      summary: Delete Recording
      description: >-
        Delete the recording information, media and transcription.


        Note: After the deletion is requested and a `204` is returned, neither
        the recording metadata nor the actual media nor its transcription will
        be accessible anymore. However, the media of the specified recording is
        not deleted immediately. This deletion process, while transparent and
        irreversible, can take an additional 24 to 48 hours.
      operationId: deleteRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '204':
          description: Recording Deleted
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41'
            \
                -X DELETE \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        await client.Voice.APIController.DeleteRecordingAsync(accountId, callId, recordingId);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().deleteRecordingAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const deleteRecording = async function() {
              // Delete the recording information, media and transcription.
              try {
                  const response = await controller.deleteRecording(accountId, callId, recordingId);
                  console.log(response.body);
              } catch(error) {
                  console.error(error);
              }
            }

            deleteRecording();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $voiceClient->deleteRecording($BW_ACCOUNT_ID, $callId, $recordingId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                voice_client.delete_recording(BW_ACCOUNT_ID, call_id, recording_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                voice_client.delete_recording("12345", call_id, recording_id)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/calls/{callId}/recordings/{recordingId}/media:
    get:
      tags:
        - Recordings
      summary: Download Recording
      description: Downloads the specified recording.
      operationId: downloadCallRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '200':
          $ref: '#/components/responses/downloadRecordingMediaResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/media'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetDownloadCallRecordingAsync(accountId, callId, recordingId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.DynamicResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<DynamicResponse>> completableFuture = client.getVoiceClient().getAPIController().getDownloadCallRecordingAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            try {
                const response = await controller.getDownloadCallRecording(accountId, callId, recordingId);
                console.log(response);
            } catch (error) {
                console.error(error);
            }
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $response = $voiceClient->getDownloadCallRecording($BW_ACCOUNT_ID, $callId, $recordingId);
                $downloaded_recording = $response->getResult();
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                response = voice_client.get_download_call_recording(BW_ACCOUNT_ID, call_id, recording_id)
                downloaded_recording = response.body
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: BW_USERNAME,
                voice_basic_auth_password: BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                result = voice_client.get_download_call_recording(BW_ACCOUNT_ID, call_id, recording_id)
                downloaded_recording = result.data
            rescue APIException => e
                puts e.response_code
            end
    delete:
      tags:
        - Recordings
      summary: Delete Recording Media
      description: Deletes the specified recording's media.
      operationId: deleteRecordingMedia
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '204':
          description: The recording media was successfully deleted
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/media'
            \
                -X DELETE \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        await client.Voice.APIController.DeleteRecordingMediaAsync(accountId, callId, recordingId);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().deleteRecordingMediaAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const deleteRecordingMedia = async function() {
              // Delete the media of the specified recording.
              try {
                  const response = await controller.deleteRecordingMedia(accountId, callId, recordingId);
                  console.log(response.body);
              } catch(error) {
                  console.error(error);
              }
            }

            deleteRecordingMedia();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $voiceClient->deleteRecordingMedia($BW_ACCOUNT_ID, $callId, $recordingId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                voice_client.delete_recording_media(BW_ACCOUNT_ID, call_id, recording_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                voice_client.delete_recording_media("12345", call_id, recording_id)
            rescue APIException => e
                print(e.response_code)
            end
  /accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription:
    get:
      tags:
        - Recordings
      summary: Get Transcription
      description: >-
        Downloads the specified transcription.

        If the recording was multi-channel, then there will be 2 transcripts.

        The caller/called party transcript will be the first item while
        [`<PlayAudio>`](/docs/voice/bxml/playAudio) and
        [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be
        the second item.

        During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript
        will be the first item while the B-leg transcript will be the second
        item.
      operationId: getRecordingTranscription
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '200':
          $ref: '#/components/responses/getRecordingTranscriptionResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
    post:
      tags:
        - Recordings
      summary: Create Transcription Request
      description: >-
        Generate the transcription for a specific recording. Transcription

        can succeed only for recordings of length greater than 500 milliseconds
        and

        less than 4 hours.
      operationId: transcribeCallRecording
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      requestBody:
        $ref: '#/components/requestBodies/transcribeRecordingRequest'
      responses:
        '204':
          description: Transcription successfully requested
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/transcription'
            \
                -X POST \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=' \
                -H 'Content-Type: application/json' \
                -d '{
                    "callbackUrl": "http://example.com",
                    "callbackMethod": "POST",
                    "username": "string",
                    "password": "string",
                    "tag": "string",
                    "callbackTimeout": 0"
                }'
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    var baseUrl = "https://sample.com";
                    var transcribeUrl = string.Concat(baseUrl, "/callbacks/transcribe");

                    var request = new TranscribeRecordingRequest
                    {
                        CallbackUrl = transcribeUrl
                    };

                    try
                    {
                        await client.Voice.APIController.CreateTranscribeCallRecordingAsync(accountId, callId, recordingId, request);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.*;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    TranscribeRecordingRequest request = new TranscribeRecordingRequest();
                    request.setCallbackUrl("https://sample.com/callbacks/transcribe");

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().createTranscribeCallRecordingAsync(ACCOUNT_ID, callId, recordingId, request);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const transcribeRecording = async function() {
              try {
                  const response = await controller.createTranscribeCallRecording(accountId, callId, recordingId, {
                    callbackUrl: 'https://www.myapp.com/transcription'
                  });
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            transcribeRecording();
        - lang: PHP
          source: |
            <?php
              
            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            $body = new BandwidthLib\Voice\Models\TranscribeRecordingRequest();
            $body->callbackUrl = "https://callback-url.com";

            try {
                $voiceClient->createTranscribeCallRecording($BW_ACCOUNT_ID, $callId, $recordingId, $body);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: >
            from bandwidth.bandwidth_client import BandwidthClient

            from bandwidth.voice.models.transcribe_recording_request import
            TranscribeRecordingRequest

            from bandwidth.exceptions.api_exception import APIException


            import os


            BW_USERNAME = "api-username"

            BW_PASSWORD = "api-password"

            BW_ACCOUNT_ID = "12345"


            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )

            voice_client = bandwidth_client.voice_client.client


            call_id = "c-1234"

            recording_id = "r-1234"


            body = TranscribeRecordingRequest()

            body.callback_url = "https://callback-url.com"


            try:
                voice_client.create_transcribe_call_recording(BW_ACCOUNT_ID, call_id, recording_id, body)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |+
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            body = TranscribeRecordingRequest.new
            body.callback_url = "https://callback-url.com"

            begin
                voice_client.create_transcribe_call_recording("12345", call_id, recording_id, body)
            rescue APIException => e
                puts e.response_code
            end

    delete:
      tags:
        - Recordings
      summary: Delete Transcription
      description: >-
        Deletes the specified recording's transcription.


        Note: After the deletion is requested and a `204` is returned, the
        transcription will not be accessible anymore. However, it is not deleted
        immediately. This deletion process, while transparent and irreversible,
        can take an additional 24 to 48 hours.
      operationId: deleteCallTranscription
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/recordingId'
      responses:
        '204':
          description: The transcription was successfully deleted
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/transcription'
            \
                -X DELETE \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        await client.Voice.APIController.DeleteCallTranscriptionAsync(accountId, callId, recordingId);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<Void>> completableFuture = client.getVoiceClient().getAPIController().deleteCallTranscriptionAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const deleteTranscription = async function() {
              try {
                  const response = await controller.deleteCallTranscription(accountId, callId, recordingId);
                  console.log(response.body);
              } catch(error) {
                  console.error(error);
              }
            }

            deleteTranscription();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $voiceClient->deleteCallTranscription($BW_ACCOUNT_ID, $callId, $recordingId);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                voice_client.delete_call_transcription(BW_ACCOUNT_ID, call_id, recording_id)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                voice_client.delete_call_transcription("12345", call_id, recording_id)
            rescue APIException => e
                puts e.response_code
            end
  /accounts/{accountId}/statistics:
    get:
      tags:
        - Statistics
      summary: Get Account Statistics
      description: Returns details about the current state of the account.
      operationId: getStatistics
      parameters:
        - $ref: '#/components/parameters/accountId'
      responses:
        '200':
          $ref: '#/components/responses/getStatisticsResponse'
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
  /accounts/{accountId}/calls/{callId}/transcriptions:
    get:
      tags:
        - Transcriptions
      summary: Retrieve transcriptions made on a call
      description: >-
        Enumerates the transcriptions created on this call via
        [startTranscription](/docs/voice/bxml/startTranscription).
      operationId: listTranscriptions
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
      responses:
        '200':
          $ref: u/components/responses/getCallTranscriptionsResponse
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
  /accounts/{accountId}/calls/{callId}/transcriptions/{transcriptionId}:
    get:
      tags:
        - Transcriptions
      summary: Retrieve a specific transcription
      description: >-
        Retrieve the specified transcription that was created on this call via
        [startTranscription](/docs/voice/bxml/startTranscription).
      operationId: getCallTranscription
      parameters:
        - $ref: '#/components/parameters/accountId'
        - $ref: '#/components/parameters/callId'
        - $ref: '#/components/parameters/transcriptionId'
      responses:
        '200':
          $ref: u/components/responses/getCallTranscriptionResponse
        '400':
          $ref: '#/components/responses/voiceBadRequestError'
        '401':
          $ref: '#/components/responses/voiceUnauthorizedError'
        '403':
          $ref: '#/components/responses/voiceForbiddenError'
        '404':
          $ref: '#/components/responses/voiceNotFoundError'
        '405':
          $ref: '#/components/responses/voiceNotAllowedError'
        '415':
          $ref: '#/components/responses/voiceUnsupportedMediaTypeError'
        '429':
          $ref: '#/components/responses/voiceTooManyRequestsError'
        '500':
          $ref: '#/components/responses/voiceInternalServerError'
      x-codeSamples:
        - lang: cURL
          source: >
            curl
            'https://voice.bandwidth.com/api/v2/accounts/12345/calls/c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d/recordings/r-d68201ef-d53e-4c6d-a743-1c1283909d41/transcription'
            \
                -H 'Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ='
        - lang: C#
          source: |
            using System;
            using System.Threading.Tasks;
            using Bandwidth.Standard;
            using Bandwidth.Standard.Exceptions;
            using Bandwidth.Standard.Voice.Models;

            class Program
            {
                static async Task Main(string[] args)
                {
                    var username = "api-username";
                    var password = "api-pasword";
                    var accountId = "12345";

                    // Call id is returned after successfully creating a call.
                    var callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    var recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    var client = new BandwidthClient.Builder()
                        .VoiceBasicAuthCredentials(username, password)
                        .Build();

                    try
                    {
                        var response = await client.Voice.APIController.GetCallTranscriptionAsync(accountId, callId, recordingId);
                        Console.WriteLine(response.Data);
                    }
                    catch (ApiException e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        - lang: Java
          source: |
            import com.bandwidth.BandwidthClient;
            import com.bandwidth.http.response.ApiResponse;
            import com.bandwidth.voice.models.TranscriptionResponse;

            import java.util.concurrent.CompletableFuture;
            import java.util.concurrent.ExecutionException;

            public class Sample {
                public static final String USERNAME = "api-username";
                public static final String PASSWORD = "api-password";
                public static final String ACCOUNT_ID = "12345";

                public static void main(String[] args) {
                    // Call id is returned after successfully creating a call.
                    String callId = "c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d";
                    // Recording id is returned after retrieving a recording from the call.
                    String recordingId = "r-d68201ef-d53e-4c6d-a743-1c1283909d41";

                    BandwidthClient client = new BandwidthClient.Builder()
                            .voiceBasicAuthCredentials(USERNAME, PASSWORD)
                            .build();

                    try {
                        CompletableFuture<ApiResponse<TranscriptionResponse>> completableFuture = client.getVoiceClient().getAPIController().getCallTranscriptionAsync(ACCOUNT_ID, callId, recordingId);
                        System.out.println(completableFuture.get().getResult());
                    } catch (InterruptedException | ExecutionException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        - lang: Node.js
          source: |
            import { Client, ApiController } from '@bandwidth/voice';

            const BW_USERNAME = "api-username";
            const BW_PASSWORD = "api-password";
            const BW_ACCOUNT_ID = "12345";

            const client = new Client({
              basicAuthUserName: BW_USERNAME,
              basicAuthPassword: BW_PASSWORD
            });

            const controller = new ApiController(client);

            const accountId = BW_ACCOUNT_ID;

            const callId = 'c-abc12345-6defabc1-2345-6def-abc1-23456defabc1';
            const recordingId = 'r-abc12345-6def-abc1-2345-6defabc12345';

            const getCallTranscription = async function() {
              try {
                  const response = await controller.getCallTranscription(accountId, callId, recordingId);
                  console.log(response)
              } catch(error) {
                  console.error(error);
              }
            }

            getCallTranscription();
        - lang: PHP
          source: |
            <?php

            require "vendor/autoload.php";

            api-username = "api-username";
            api-password = "api-pasword";
            12345 = "12345";

            $config = new BandwidthLib\Configuration(
                array(
                    'voiceBasicAuthUserName' => $BW_USERNAME,
                    'voiceBasicAuthPassword' => $BW_PASSWORD,
                )
            );
            $client = new BandwidthLib\BandwidthClient($config);

            $voiceClient = $client->getVoice()->getClient();

            $callId = "c-1234";
            $recordingId = "r-1234";

            try {
                $response = $voiceClient->getCallTranscription($BW_ACCOUNT_ID, $callId, $recordingId);
                print_r($response->getResult()->transcripts);
            } catch (BandwidthLib\APIException $e) {
                print_r($e->getResponseCode());
            }
        - lang: Python
          source: |
            from bandwidth.bandwidth_client import BandwidthClient
            from bandwidth.exceptions.api_exception import APIException

            import os

            BW_USERNAME = "api-username"
            BW_PASSWORD = "api-password"
            BW_ACCOUNT_ID = "12345"

            bandwidth_client = BandwidthClient(
                voice_basic_auth_user_name=BW_USERNAME,
                voice_basic_auth_password=BW_PASSWORD
            )
            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            try:
                response = voice_client.get_call_transcription(BW_ACCOUNT_ID, call_id, recording_id)
                print(response.body.transcripts)
            except APIException as e:
                print(e.response_code)
        - lang: Ruby
          source: |
            require 'bandwidth'
              
            include Bandwidth
            include Bandwidth::Voice

            bandwidth_client = Bandwidth::Client.new(
                voice_basic_auth_user_name: "api-username",
                voice_basic_auth_password: "api-password"
            )

            voice_client = bandwidth_client.voice_client.client

            call_id = "c-1234"
            recording_id = "r-1234"

            begin
                response = voice_client.get_call_transcription("12345", call_id, recording_id)
                puts response.data.transcripts
            rescue APIException => e
                puts e.response_code
            end
components:
  schemas:
    callbackMethodEnum:
      type: string
      nullable: true
      default: POST
      enum:
        - GET
        - POST
      description: >-
        The HTTP method to use to deliver the callback. GET or POST. Default
        value is POST.
      example: POST
    redirectMethodEnum:
      type: string
      nullable: true
      default: POST
      enum:
        - GET
        - POST
      description: >-
        The HTTP method to use for the request to `redirectUrl`. GET

        or POST. Default value is POST.<br><br>Not allowed if `state` is
        `completed`
      example: POST
    recordingStateEnum:
      type: string
      enum:
        - paused
        - recording
      description: |-
        The recording state. Possible values:

        `paused` to pause an active recording

        `recording` to resume a paused recording
    callDirectionEnum:
      type: string
      enum:
        - inbound
        - outbound
      description: The direction of the call.
    fileFormatEnum:
      type: string
      enum:
        - mp3
        - wav
      description: The format that the recording is stored in
    callStateEnum:
      nullable: true
      type: string
      default: active
      enum:
        - active
        - completed
      description: >-
        The call state. Possible values:<br>`active` to redirect the

        call (default)<br>`completed` to hang up the call if it is answered,
        cancel

        it if it is an unanswered outbound call, or reject it if it an
        unanswered

        inbound call
    conferenceStateEnum:
      nullable: true
      type: string
      default: active
      enum:
        - active
        - completed
      description: >-
        Setting the conference state to `completed` ends the conference and
        ejects all members
    machineDetectionModeEnum:
      type: string
      default: async
      enum:
        - sync
        - async
      description: >-
        The machine detection mode. If set to 'async', the detection

        result will be sent in a 'machineDetectionComplete' callback. If set to

        'sync', the 'answer' callback will wait for the machine detection to
        complete

        and will include its result.
    createCall:
      type: object
      required:
        - answerUrl
        - applicationId
        - from
        - to
      properties:
        to:
          type: string
          description: |-
            The destination to call (must be an E.164 formatted number
            (e.g. `+15555551212`) or a SIP URI (e.g. `sip:user@server.com`)).
          example: '+19195551234'
        from:
          type: string
          description: >-
            A Bandwidth phone number on your account the call should come

            from (must be in E.164 format, like `+15555551212`, or be one of the
            following

            strings: `Restricted`, `Anonymous`, `Private`, or `Unavailable`).
          example: '+19195554321'
        uui:
          nullable: true
          type: string
          example: >-
            eyJhbGciOiJIUzI1NiJ9.WyJoaSJd.-znkjYyCkgz4djmHUPSXl9YrJ6Nix_XvmlwKGFh5ERM;encoding=jwt,aGVsbG8gd29ybGQ=;encoding=base64
          description: >-
            A comma-separated list of 'User-To-User' headers to be sent

            in the INVITE when calling a SIP URI. Each value must end with an
            'encoding'

            parameter as described in <a
            href='https://tools.ietf.org/html/rfc7433'>RFC

            7433</a>. Only 'jwt' and 'base64' encodings are allowed. The entire
            value

            cannot exceed 350 characters, including parameters and separators.
        applicationId:
          type: string
          description: The id of the application associated with the `from` number.
          example: 1234-qwer-5679-tyui
        answerUrl:
          type: string
          format: uri
          description: >-
            The full URL to send the <a
            href='/docs/voice/webhooks/answer'>Answer</a>

            event to when the called party answers. This endpoint should return
            the

            first <a href='/docs/voice/bxml'>BXML document</a> to be executed in
            the

            call.


            Must use `https` if specifying `username` and `password`
          maxLength: 2048
          example: https://www.myCallbackServer.com/webhooks/answer
        answerMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        answerFallbackUrl:
          nullable: true
          type: string
          format: uri
          description: >-
            A fallback url which, if provided, will be used to retry the

            `answer` webhook delivery in case `answerUrl` fails to respond


            Must use `https` if specifying `fallbackUsername` and
            `fallbackPassword`
          maxLength: 2048
          example: https://www.myFallbackServer.com/webhooks/answer
        answerFallbackMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        fallbackUsername:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        fallbackPassword:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        disconnectUrl:
          nullable: true
          type: string
          format: uri
          description: >-
            The URL to send the <a
            href='/docs/voice/webhooks/disconnect'>Disconnect</a> event to when
            the call ends. This event does not expect a BXML response.
          maxLength: 2048
        disconnectMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        callTimeout:
          nullable: true
          type: number
          format: double
          description: >-
            The timeout (in seconds) for the callee to answer the call

            after it starts ringing. If the call does not start ringing within
            30s,

            the call will be cancelled regardless of this value.  Can be any
            numeric

            value (including decimals) between 1 and 300.
          minimum: 1
          maximum: 300
          default: 30
        callbackTimeout:
          nullable: true
          type: number
          format: double
          description: >-
            This is the timeout (in seconds) to use when delivering webhooks

            for the call. Can be any numeric value (including decimals) between
            1

            and 25.
          minimum: 1
          maximum: 25
          default: 15
        machineDetection:
          $ref: '#/components/schemas/machineDetectionConfiguration'
        priority:
          nullable: true
          type: integer
          minimum: 1
          maximum: 5
          default: 5
          description: >-
            The priority of this call over other calls from your account. For
            example, if during a call

            your application needs to place a new call and bridge it with the
            current

            call, you might want to create the call with priority 1 so that it
            will

            be the next call picked off your queue, ahead of other less time
            sensitive

            calls. A lower value means higher priority, so a priority 1 call
            takes

            precedence over a priority 2 call.
        tag:
          nullable: true
          type: string
          description: >-
            A custom string that will be sent with all webhooks for this

            call unless overwritten by a future <a
            href='/docs/voice/bxml/tag'>`<Tag>`</a>

            verb or `tag` attribute on another verb, or cleared.


            May be cleared by setting `tag=""`


            Max length 256 characters.
          maximum: 256
    createCallResponse:
      type: object
      required:
        - accountId
        - answerMethod
        - answerUrl
        - applicationId
        - callId
        - callUrl
        - disconnectMethod
        - from
        - to
      properties:
        applicationId:
          type: string
          example: 04e88489-df02-4e34-a0ee-27a91849555f
          description: The id of the application associated with the `from` number.
        accountId:
          type: string
          example: '9900000'
          description: The bandwidth account ID associated with the call
        callId:
          type: string
          example: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
          description: Programmable Voice API Call ID
        to:
          type: string
          example: '+19195551234'
          description: Recipient of the outgoing call
        from:
          type: string
          example: '+19195554321'
          description: Phone number that created the outbound call
        enqueuedTime:
          nullable: true
          type: string
          format: date-time
          description: Time the call was accepted into the queue
          example: '2022-06-16T13:15:07.160Z'
        callUrl:
          type: string
          format: uri
          example: >-
            https://voice.bandwidth.com/api/v2/accounts/9900000/calls/c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
          description: The URL to update call state
        callTimeout:
          type: number
          format: double
          example: 30
          description: >-
            The timeout (in seconds) for the callee to answer the call after it
            starts ringing.
        callbackTimeout:
          type: number
          format: double
          example: 15
          description: >-
            This is the timeout (in seconds) to use when delivering webhooks for
            the call.
        tag:
          nullable: true
          type: string
          example: My custom tag value
          description: Custom tag value
        answerMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        answerUrl:
          type: string
          format: uri
          example: https://myServer.com/bandwidth/webhooks/answer
          description: URL to deliver the `answer` event webhook.
        answerFallbackMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        answerFallbackUrl:
          nullable: true
          type: string
          format: uri
          example: https://myFallbackServer.com/bandwidth/webhooks/answer
          description: Fallback URL to deliver the `answer` event webhook.
        disconnectMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        disconnectUrl:
          nullable: true
          type: string
          format: uri
          example: https://myServer.com/bandwidth/webhooks/disconnect
          description: URL to deliver the `disconnect` event webhook.
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        fallbackUsername:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        fallbackPassword:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        priority:
          nullable: true
          type: number
          format: integer
          example: 5
          description: The priority of this call over other calls from your account.
    callState:
      type: object
      properties:
        applicationId:
          type: string
          description: The application id associated with the call.
          example: 04e88489-df02-4e34-a0ee-27a91849555f
        accountId:
          type: string
          description: The account id associated with the call.
          example: '9900000'
        callId:
          type: string
          description: The programmable voice API call ID.
          example: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
        parentCallId:
          nullable: true
          type: string
          description: >-
            The A-leg call id, set only if this call is the B-leg of a
            [`<Transfer>`](/docs/voice/bxml/transfer).
          example: c-25ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
        to:
          type: string
          description: >-
            The phone number that received the call, in E.164 format (e.g.
            +15555555555), or if the call was to a SIP URI, the SIP URI
          example: '+19195551234'
        from:
          type: string
          description: >-
            The phone number that made the call, in E.164 format (e.g.
            +15555555555).
          example: '19195554321'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        state:
          description: >-
            The current state of the call. Current possible values are

            `queued`, `initiated`, `answered` and `disconnected`. Additional
            states

            may be added in the future, so your application must be tolerant of
            unknown

            values.
          type: string
          example: disconnected
        stirShaken:
          nullable: true
          type: object
          description: >-
            For inbound calls, the Bandwidth STIR/SHAKEN implementation will
            verify the information provided in the inbound invite request
            `Identity` header.

            The verification status is stored in the call state `stirShaken`
            property as follows.


            | Property          | Description |

            |:------------------|:------------|

            | verstat | (optional) The verification status indicating whether
            the verification was successful or not. Possible values are
            `TN-Verification-Passed` or `TN-Verification-Failed`. |

            | attestationIndicator | (optional) The attestation level verified
            by Bandwidth. Possible values are `A` (full), `B` (partial) or `C`
            (gateway). |

            | originatingId | (optional) A unique origination identifier. |


            Note that these are common properties but that the `stirShaken`
            object is free form and can contain other key-value pairs.


            More information: [Understanding
            STIR/SHAKEN](https://www.bandwidth.com/regulations/stir-shaken)
          additionalProperties:
            type: string
          example:
            verstat: TN-Verification-Passed
            attestationIndicator: A
            originatingId: abc123
        identity:
          nullable: true
          type: string
          description: >-
            The value of the `Identity` header from the inbound invite

            request. Only present for inbound calls and if the account is
            configured

            to forward this header.
          example: >-
            eyJhbGciOiJFUzI1NiIsInBwdCI6InNoYWtlbiIsInR5cCI6InBhc3Nwb3J0IiwieDV1IjoiaHR0cHM6Ly9idy1zaGFrZW4tY2VydC1wdWIuczMuYW1hem9uYXdzLmNvbS9iYW5kd2lkdGgtc2hha2VuLWNlcnRfMjAyMzA3MTYucGVtIn0.eyJhdHRlc3QiOiJBIiwiZGVzdCI6eyJ0biI6WyIxOTg0MjgyMDI4MCJdfSwiaWF0IjoxNjU2NTM0MzM2LCJvcmlnIjp7InRuIjoiMTkxOTQ0NDI2ODMifSwib3JpZ2lkIjoiNDk0NTlhOGEtNDJmNi0zNTFjLTkzNjEtYWRmNTdhOWUwOGNhIn0.56un9sRw_uH-sbJvnUsqdevlVxbOVjn8MVlGTlBMicjaZuRRwxfiNp-C9zYCMKTTCbc-QdYPN05F61XNVN4D3w;info=<https://bw-shaken-cert-pub.s3.amazonaws.com/bandwidth-shaken-cert_20230716.pem>;alg=ES256;ppt=shaken
        enqueuedTime:
          nullable: true
          type: string
          format: date-time
          description: The time this call was placed in queue.
          example: '2022-06-16T13:15:07.160Z'
        startTime:
          nullable: true
          type: string
          format: date-time
          description: >-
            The time the call was initiated, in ISO 8601 format. `null` if the
            call is still in your queue.
          example: '2022-06-16T13:15:07.160Z'
        answerTime:
          nullable: true
          type: string
          format: date-time
          description: >-
            Populated once the call has been answered, with the time in ISO 8601
            format.
          example: '2022-06-16T13:15:18.126Z'
        endTime:
          nullable: true
          type: string
          format: date-time
          description: Populated once the call has ended, with the time in ISO 8601 format.
          example: '2022-06-16T13:15:18.314Z'
        disconnectCause:
          nullable: true
          type: string
          description: >-
            | Cause | Description |

            |:------|:------------|

            | `hangup`| One party hung up the call, a
            [`<Hangup>`](../../bxml/verbs/hangup.md) verb was executed, or there
            was no more BXML to execute; it indicates that the call ended
            normally. |

            | `busy` | Callee was busy. |

            | `timeout` | Call wasn't answered before the `callTimeout` was
            reached. |

            | `cancel` | Call was cancelled by its originator while it was
            ringing. |

            | `rejected` | Call was rejected by the callee. |

            | `callback-error` | BXML callback couldn't be delivered to your
            callback server. |

            | `invalid-bxml` | Invalid BXML was returned in response to a
            callback. |

            | `application-error` | An unsupported action was tried on the call,
            e.g. trying to play a .ogg audio. |

            | `account-limit` | Account rate limits were reached. |

            | `node-capacity-exceeded` | System maximum capacity was reached. |

            | `error` | Some error not described in any of the other causes
            happened on the call. |

            | `unknown` | Unknown error happened on the call. |


            Note: This list is not exhaustive and other values can appear in the
            future.
        errorMessage:
          nullable: true
          type: string
          description: >-
            Populated only if the call ended with an error, with text explaining
            the reason.
          example: null
        errorId:
          nullable: true
          type: string
          description: >-
            Populated only if the call ended with an error, with a Bandwidth
            internal id that references the error event.
          example: null
        lastUpdate:
          type: string
          format: date-time
          description: The last time the call had a state update, in ISO 8601 format.
          example: '2022-06-16T13:15:18.314Z'
    updateCall:
      type: object
      properties:
        state:
          $ref: '#/components/schemas/callStateEnum'
        redirectUrl:
          description: |-
            The URL to send the [Redirect](/docs/voice/bxml/redirect) event
            to which will provide new BXML.

            Required if `state` is `active`.

            Not allowed if `state` is `completed`.
          nullable: true
          type: string
          format: uri
          example: https://myServer.com/bandwidth/webhooks/redirect
        redirectMethod:
          $ref: '#/components/schemas/redirectMethodEnum'
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        redirectFallbackUrl:
          nullable: true
          type: string
          format: uri
          description: |-
            A fallback url which, if provided, will be used to retry the
            redirect callback delivery in case `redirectUrl` fails to respond
          example: https://myFallbackServer.com/bandwidth/webhooks/redirect
        redirectFallbackMethod:
          $ref: '#/components/schemas/redirectMethodEnum'
        fallbackUsername:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        fallbackPassword:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        tag:
          nullable: true
          type: string
          description: >-
            A custom string that will be sent with this and all future

            callbacks unless overwritten by a future `tag` attribute or
            [`<Tag>`](/docs/voice/bxml/tag)

            verb, or cleared.


            May be cleared by setting `tag=""`.


            Max length 256 characters.


            Not allowed if `state` is `completed`.
          maximum: 256
          example: My Custom Tag
    updateCallRecording:
      type: object
      required:
        - state
      properties:
        state:
          $ref: '#/components/schemas/recordingStateEnum'
    accountStatistics:
      type: object
      properties:
        currentCallQueueSize:
          type: integer
          description: The number of calls currently enqueued.
          example: 0
        maxCallQueueSize:
          type: integer
          description: >-
            The maximum size of the queue before outgoing calls start being
            rejected.
          example: 900
    callRecordingMetadata:
      type: object
      properties:
        applicationId:
          $ref: '#/components/schemas/applicationId'
        accountId:
          $ref: '#/components/schemas/accountId'
        callId:
          $ref: '#/components/schemas/callId'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        to:
          $ref: '#/components/schemas/to'
        from:
          $ref: '#/components/schemas/from'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
        duration:
          $ref: '#/components/schemas/duration'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        channels:
          $ref: '#/components/schemas/channels'
        startTime:
          $ref: '#/components/schemas/startTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        status:
          $ref: '#/components/schemas/status'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
        transcription:
          $ref: '#/components/schemas/recordingTranscriptionMetadata'
    conference:
      type: object
      properties:
        id:
          type: string
          description: The Bandwidth-generated conference ID
          example: conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9
        name:
          type: string
          description: The name of the conference, as specified by your application
          example: my-conference-name
        createdTime:
          type: string
          format: date-time
          description: The time the conference was initiated, in ISO 8601 format.
          example: '2022-06-17T22:19:40.375Z'
        completedTime:
          nullable: true
          type: string
          format: date-time
          description: The time the conference was terminated, in ISO 8601 format.
          example: '2022-06-17T22:20:00.000Z'
        conferenceEventUrl:
          nullable: true
          type: string
          format: uri
          description: The URL to send the conference-related events.
          example: https://myServer.com/bandwidth/webhooks/conferenceEvent
        conferenceEventMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        tag:
          nullable: true
          type: string
          description: >-
            The custom string attached to the conference that will be sent with
            callbacks.
          example: my custom tag
        activeMembers:
          type: array
          nullable: true
          items:
            $ref: '#/components/schemas/conferenceMember'
          description: >-
            A list of active members of the conference. Omitted if this

            is a response to the [Get Conferences
            endpoint](/apis/voice#tag/Conferences/operation/listConferences)
    updateConference:
      type: object
      properties:
        status:
          $ref: '#/components/schemas/conferenceStateEnum'
        redirectUrl:
          nullable: true
          type: string
          format: uri
          description: >-
            The URL to send the
            [conferenceRedirect](/docs/voice/webhooks/conferenceRedirect)

            event which will provide new BXML. Not allowed if `state` is
            `completed`,

            but required if `state` is `active`
          example: https://myServer.com/bandwidth/webhooks/conferenceRedirect
        redirectMethod:
          $ref: '#/components/schemas/redirectMethodEnum'
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        redirectFallbackUrl:
          nullable: true
          type: string
          format: uri
          description: >-
            A fallback url which, if provided, will be used to retry the

            `conferenceRedirect` webhook delivery in case `redirectUrl` fails to
            respond.  Not

            allowed if `state` is `completed`.
          example: https://myFallbackServer.com/bandwidth/webhooks/conferenceRedirect
        redirectFallbackMethod:
          $ref: '#/components/schemas/redirectMethodEnum'
        fallbackUsername:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        fallbackPassword:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
    conferenceMember:
      type: object
      properties:
        callId:
          $ref: '#/components/schemas/callId'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        memberUrl:
          type: string
          description: >-
            A URL that may be used to retrieve information about or update

            the state of this conference member. This is the URL of this
            member's

            [Get Conference Member](/apis/voice/#operation/getConferenceMember)
            endpoint

            and [Modify Conference
            Member](/apis/voice/#operation/updateConferenceMember)

            endpoint.
          example: >-
            https://voice.bandwidth.com/api/v2/accounts/9900000/conferences/conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9/members/c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
        mute:
          type: boolean
          description: >-
            Whether or not this member is currently muted. Members who are muted
            are still able to hear other participants.


            If used in a PUT request, updates this member's mute status. Has no
            effect if omitted.
          example: false
        hold:
          type: boolean
          description: >-
            Whether or not this member is currently on hold. Members who are on
            hold are not able to hear or speak in the conference.


            If used in a PUT request, updates this member's hold status. Has no
            effect if omitted.
          example: false
        callIdsToCoach:
          nullable: true
          type: array
          items:
            type: string
          description: >-
            If this member had a value set for `callIdsToCoach` in its
            [Conference](/docs/voice/bxml/conference) verb or this list was
            added with a previous PUT request to modify the member, this is that
            list of calls.


            If present in a PUT request, modifies the calls that this member is
            coaching. Has no effect if omitted. See the documentation for the
            [Conference](/docs/voice/bxml/conference) verb for more details
            about coaching.

            Note that this will not add the matching calls to the conference;
            each call must individually execute a Conference verb to join.
          example:
            - c-25ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    updateConferenceMember:
      type: object
      properties:
        mute:
          type: boolean
          description: >-
            Whether or not this member is currently muted. Members who are muted
            are still able to hear other participants.


            Updates this member's mute status. Has no effect if omitted.
          example: false
        hold:
          type: boolean
          description: >-
            Whether or not this member is currently on hold. Members who are on
            hold are not able to hear or speak in the conference.


            Updates this member's hold status. Has no effect if omitted.
          example: false
        callIdsToCoach:
          nullable: true
          type: array
          items:
            type: string
          description: >-
            If this member had a value set for `callIdsToCoach` in its
            [Conference](/docs/voice/bxml/conference) verb or this list was
            added with a previous PUT request to modify the member, this is that
            list of calls.


            Modifies the calls that this member is coaching. Has no effect if
            omitted. See the documentation for the
            [Conference](/docs/voice/bxml/conference) verb for more details
            about coaching.


            Note that this will not add the matching calls to the conference;
            each call must individually execute a Conference verb to join.
          example:
            - c-25ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    conferenceRecordingMetadata:
      type: object
      properties:
        accountId:
          $ref: '#/components/schemas/accountId'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        duration:
          $ref: '#/components/schemas/duration'
        channels:
          $ref: '#/components/schemas/channels'
        startTime:
          $ref: '#/components/schemas/startTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        status:
          $ref: '#/components/schemas/status'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
    machineDetectionConfiguration:
      type: object
      description: >-
        The machine detection request used to perform <a
        href='/docs/voice/guides/machineDetection'>machine detection</a> on the
        call.
      properties:
        mode:
          $ref: '#/components/schemas/machineDetectionModeEnum'
        detectionTimeout:
          nullable: true
          type: number
          format: double
          description: >-
            The timeout used for the whole operation, in seconds. If no

            result is determined in this period, a callback with a `timeout`
            result

            is sent.
          default: 15
          example: 15
        silenceTimeout:
          nullable: true
          type: number
          format: double
          description: >-
            If no speech is detected in this period, a callback with a 'silence'
            result is sent.
          default: 10
          example: 10
        speechThreshold:
          nullable: true
          type: number
          format: double
          description: >-
            When speech has ended and a result couldn't be determined based

            on the audio content itself, this value is used to determine if the
            speaker

            is a machine based on the speech duration. If the length of the
            speech

            detected is greater than or equal to this threshold, the result will
            be

            'answering-machine'. If the length of speech detected is below this
            threshold,

            the result will be 'human'.
          default: 10
          example: 10
        speechEndThreshold:
          nullable: true
          type: number
          format: double
          description: >-
            Amount of silence (in seconds) before assuming the callee has
            finished speaking.
          default: 5
          example: 5
        machineSpeechEndThreshold:
          nullable: true
          type: number
          format: double
          description: >-
            When an answering machine is detected, the amount of silence (in
            seconds) before assuming the message has finished playing. 

            If not provided it will default to the speechEndThreshold value.
          example: 5
        delayResult:
          nullable: true
          type: boolean
          description: >-
            If set to 'true' and if an answering machine is detected, the

            'answering-machine' callback will be delayed until the machine is
            done

            speaking, or an end of message tone is detected, or until the
            'detectionTimeout' is exceeded. If false, the 'answering-machine'

            result is sent immediately.
          default: false
          example: false
        callbackUrl:
          nullable: true
          description: >-
            The URL to send the 'machineDetectionComplete' webhook when the
            detection is completed. Only for 'async' mode.
          type: string
          format: uri
          maxLength: 2048
          example: https://myServer.com/bandwidth/webhooks/machineDetectionComplete
        callbackMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        fallbackUrl:
          nullable: true
          type: string
          format: uri
          description: >-
            A fallback URL which, if provided, will be used to retry the

            machine detection complete webhook delivery in case `callbackUrl`
            fails

            to respond
          maxLength: 2048
          example: >-
            https://myFallbackServer.com/bandwidth/webhooks/machineDetectionComplete
        fallbackMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        fallbackUsername:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        fallbackPassword:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
    transcribeRecording:
      type: object
      properties:
        callbackUrl:
          type: string
          format: uri
          description: >-
            The URL to send the
            [TranscriptionAvailable](/docs/voice/webhooks/transcriptionAvailable)

            event to. You should not include sensitive or
            personally-identifiable

            information in the callbackUrl field! Always use the proper username
            and

            password fields for authorization.
          example: https://myServer.com/bandwidth/webhooks/transcriptionAvailable
        callbackMethod:
          $ref: '#/components/schemas/callbackMethodEnum'
        username:
          type: string
          nullable: true
          description: Basic auth username.
          maxLength: 1024
          example: mySecretUsername
        password:
          type: string
          nullable: true
          description: Basic auth password.
          maxLength: 1024
          example: mySecretPassword1!
        tag:
          $ref: '#/components/schemas/tag'
        callbackTimeout:
          nullable: true
          type: number
          format: double
          minimum: 1
          maximum: 25
          default: 15
          description: >-
            This is the timeout (in seconds) to use when delivering the

            webhook to `callbackUrl`. Can be any numeric value (including
            decimals)

            between 1 and 25.
          example: 5.5
        detectLanguage:
          type: boolean
          nullable: true
          description: >-
            A boolean value to indicate that the recording may not be in
            English, and the transcription service will need to detect the
            dominant language the recording is in and transcribe accordingly.
            Current supported languages are English, French, and Spanish.
          default: false
          example: true
    recordingTranscriptions:
      type: object
      properties:
        transcripts:
          type: array
          items:
            $ref: '#/components/schemas/recordingTranscription'
    callTranscriptionList:
      type: array
      items:
        $ref: '#/components/schemas/callTranscription'
    callTranscription:
      type: object
      properties:
        detectedLanguage:
          type: string
          enum:
            - de-DE
            - en-AU
            - en-GB
            - en-US
            - es-US
            - fr-CA
            - fr-FR
            - hi-IN
            - it-IT
            - ja-JP
            - ko-KR
            - pt-BR
            - th-TH
            - zh-CN
          description: The detected language for this transcription.
          example: en-US
        track:
          type: string
          enum:
            - inbound
            - outbound
          description: Which `track` this transcription is derived from.
          example: inbound
        text:
          type: string
          description: The transcription itself.
          example: Hello World! This is an example.
        confidence:
          type: number
          format: double
          minimum: 0
          maximum: 1
          description: >-
            How confident the transcription engine was in transcribing the
            associated audio (from `0` to `1`).
          example: 0.9
    recordingTranscriptionMetadata:
      nullable: true
      type: object
      description: If the recording was transcribed, metadata about the transcription
      properties:
        id:
          type: string
          description: The unique transcription ID
          example: t-387bd648-18f3-4823-9d16-746bca0003c9
        status:
          $ref: '#/components/schemas/status'
        completedTime:
          type: string
          description: The time that the transcription was completed
          example: '2022-06-13T18:46:29.715Z'
        url:
          type: string
          format: uri
          description: The URL of the [transcription](#operation/getCallTranscription)
          example: >-
            https://voice.bandwidth.com/api/v2/accounts/9900000/calls/c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85/recordings/r-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85/transcription
    voiceApiError:
      type: object
      properties:
        type:
          type: string
        description:
          type: string
        id:
          nullable: true
          type: string
    answerCallback:
      type: object
      description: >-
        The Answer event is sent to the answerUrl specified in the createCall
        request when an outbound call is answered.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        machineDetectionResult:
          $ref: '#/components/schemas/machineDetectionResult'
    bridgeCompleteCallback:
      type: object
      description: >-
        If the target call leaves the <Bridge>, then this callback is sent to
        the bridgeCompleteUrl, and the BXML returned in it is executed on the
        call. If this webhook is sent, the Bridge Target Complete webhook is NOT
        sent. This callback is also sent if any problem occurs that prevents the
        calls to be bridged.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        cause:
          $ref: '#/components/schemas/cause'
        errorMessage:
          $ref: '#/components/schemas/errorMessage'
        errorId:
          $ref: '#/components/schemas/errorId'
    bridgeTargetCompleteCallback:
      type: object
      description: >-
        If the originating call leaves the <Bridge>, then this callback is sent
        to the bridgeTargetCompleteUrl, and the BXML returned in it is executed
        on the target call. If this webhook is sent, the Bridge Complete webhook
        is NOT sent.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceCreatedCallback:
      type: object
      description: >-
        The Conference Created event is fired whenever a new conference that
        specified a callbackUrl is created. The response may be either empty or
        a BXML document. Only the following verbs are valid for conferences:
        PlayAudio, SpeakSentence, StartRecording, StopRecording, PauseRecording,
        ResumeRecording. Audio verbs will be heard by all members of the
        conference. Recordings capture audio from all members who are not muted
        or on hold, as well as any audio verbs that are played into the
        conference.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceRedirectCallback:
      type: object
      description: >-
        The Conference Redirect event is fired whenever an existing conference
        is modified via a POST request made to the /conferences/{conferenceId}
        endpoint. The response may be either empty or a BXML document. Only the
        following verbs are valid for conferences: PlayAudio, SpeakSentence,
        StartRecording, StopRecording, PauseRecording, ResumeRecording. Audio
        verbs will be heard by all members of the conference. Recordings capture
        audio from all members who are not muted or on hold, as well as any
        audio verbs that are played into the conference.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceMemberJoinCallback:
      type: object
      description: >-
        The Conference Member Join event is fired whenever a caller joins a
        conference that specified a callbackUrl. The response may be either
        empty or a BXML document. Only the following verbs are valid for
        conferences: PlayAudio, SpeakSentence, StartRecording, StopRecording,
        PauseRecording, ResumeRecording. Audio verbs will be heard by all
        members of the conference. Recordings capture audio from all members who
        are not muted or on hold, as well as any audio verbs that are played
        into the conference.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        callId:
          $ref: '#/components/schemas/callId'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceMemberExitCallback:
      type: object
      description: >-
        The Conference Member Exit event is fired whenever a caller exits a
        conference that specified a callbackUrl. The response may be either
        empty or a BXML document. Only the following verbs are valid for
        conferences: PlayAudio, SpeakSentence, StartRecording, StopRecording,
        PauseRecording, ResumeRecording. Audio verbs will be heard by all
        members of the conference. Recordings capture audio from all members who
        are not muted or on hold, as well as any audio verbs that are played
        into the conference.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        callId:
          $ref: '#/components/schemas/callId'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceCompletedCallback:
      type: object
      description: >-
        The Conference Completed event is fired when the last member leaves the
        conference. The response to this event may not contain BXML.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        tag:
          $ref: '#/components/schemas/tag'
    conferenceRecordingAvailableCallback:
      type: object
      description: >-
        The Conference Recording Available event is sent after a conference
        recording has been processed. It indicates that the recording is
        available for download.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        conferenceId:
          $ref: '#/components/schemas/conferenceId'
        name:
          $ref: '#/components/schemas/name'
        accountId:
          $ref: '#/components/schemas/accountId'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        channels:
          $ref: '#/components/schemas/channels'
        startTime:
          $ref: '#/components/schemas/startTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        duration:
          $ref: '#/components/schemas/duration'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
        tag:
          $ref: '#/components/schemas/tag'
        status:
          $ref: '#/components/schemas/status'
    disconnectCallback:
      type: object
      description: The Disconnect event is fired when a call ends, for any reason.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        callId:
          $ref: '#/components/schemas/callId'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        cause:
          $ref: '#/components/schemas/cause'
        errorMessage:
          $ref: '#/components/schemas/errorMessage'
        errorId:
          $ref: '#/components/schemas/errorId'
        tag:
          $ref: '#/components/schemas/tag'
    dtmfCallback:
      type: object
      description: >-
        The DTMF event is sent for every digit detected after a <StartGather>
        verb is executed. You may not respond to this event with BXML.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        callId:
          $ref: '#/components/schemas/callId'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        digit:
          $ref: '#/components/schemas/digit'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
        tag:
          $ref: '#/components/schemas/tag'
    gatherCallback:
      type: object
      description: >-
        The gather event is sent after a <Gather> verb is executed. Its purpose
        is to report the gathered digits to the calling application.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        digits:
          $ref: '#/components/schemas/digits'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        terminatingDigit:
          $ref: '#/components/schemas/terminatingDigit'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
        tag:
          $ref: '#/components/schemas/tag'
    initiateCallback:
      type: object
      description: >-
        The Initiate event is fired when an inbound call is received for a
        Telephone Number on your Account. It is sent to the URL specified in the
        application associated with the location (sip-peer) that the called
        telephone number belongs to.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        startTime:
          $ref: '#/components/schemas/startTime'
        diversion:
          $ref: '#/components/schemas/diversion'
        stirShaken:
          $ref: '#/components/schemas/stirShaken'
    machineDetectionCompleteCallback:
      type: object
      description: >-
        This event is sent to the url informed when requesting a machine
        detection operation. It contains the machine detection operation result,
        which can be: human, answering-machine, silence, timeout, error. This
        event is not sent when sync answering machine detection mode is chosen.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        machineDetectionResult:
          $ref: '#/components/schemas/machineDetectionResult'
    recordingCompleteCallback:
      type: object
      description: >-
        The Record Complete event is sent after a <Record> verb has executed if
        the call is still active. The BXML returned by this callback is executed
        next. When the recording is available for download, a Recording
        Available event will be sent.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        duration:
          $ref: '#/components/schemas/duration'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        channels:
          $ref: '#/components/schemas/channels'
        tag:
          $ref: '#/components/schemas/tag'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
    recordingAvailableCallback:
      type: object
      description: >-
        The Recording Available event is sent after a recording has been
        processed. It indicates that the recording is available for download.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        duration:
          $ref: '#/components/schemas/duration'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        channels:
          $ref: '#/components/schemas/status'
        tag:
          $ref: '#/components/schemas/tag'
        status:
          $ref: '#/components/schemas/status'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
    redirectCallback:
      type: object
      description: >-
        The Redirect event is fired when a <Redirect> verb is executed. Its
        purpose is to get the next set of verbs from the calling application.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
    transcriptionAvailableCallback:
      type: object
      description: >-
        The Transcription Available event is sent when the recording
        transcription is available to be downloaded.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        mediaUrl:
          $ref: '#/components/schemas/mediaUrl'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        recordingId:
          $ref: '#/components/schemas/recordingId'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        duration:
          $ref: '#/components/schemas/duration'
        fileFormat:
          $ref: '#/components/schemas/fileFormatEnum'
        tag:
          $ref: '#/components/schemas/tag'
        transcription:
          $ref: '#/components/schemas/recordingTranscription'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
    transferAnswerCallback:
      type: object
      description: >-
        When processing a <Transfer> verb, this event is sent when a called
        party (B-leg) answers. The event is sent to the endpoint specified in
        the transferAnswerUrl attribute of the <PhoneNumber> tag that answered.
        BXML returned by this callback will be executed for the called party
        only. After all BXML has been executed, the called party will be bridged
        to the original call. Most BXML verbs are allowed in response to a
        transferAnswer event, but some are not allowed.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
    transferCompleteCallback:
      type: object
      description: >-
        This event is sent to the transferCompleteUrl of the A-leg's <Transfer>
        verb when the transferred call (B-leg) completes. In a simultaneous
        ringing scenario, only one B-leg succeeds and this event corresponds to
        that successful leg. If none of the calls were answered, the
        transferComplete event corresponds to one of the legs.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        tag:
          $ref: '#/components/schemas/tag'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
        cause:
          $ref: '#/components/schemas/cause'
        errorMessage:
          $ref: '#/components/schemas/errorMessage'
        errorId:
          $ref: '#/components/schemas/errorId'
    transferDisconnectCallback:
      type: object
      description: >-
        This event is sent to the transferDisconnectUrl of each <PhoneNumber>
        tag when its respective call leg ends for any reason. The event is sent
        in the normal case, when the transferred leg is answered and later hung
        up, but is also sent if the new leg was never answered in the first
        place, if it was rejected, and if the original call leg hung up before
        the transferred leg.
      properties:
        eventType:
          $ref: '#/components/schemas/eventType'
        eventTime:
          $ref: '#/components/schemas/eventTime'
        accountId:
          $ref: '#/components/schemas/accountId'
        applicationId:
          $ref: '#/components/schemas/applicationId'
        from:
          $ref: '#/components/schemas/from'
        to:
          $ref: '#/components/schemas/to'
        direction:
          $ref: '#/components/schemas/callDirectionEnum'
        callId:
          $ref: '#/components/schemas/callId'
        callUrl:
          $ref: '#/components/schemas/callUrl'
        parentCallId:
          $ref: '#/components/schemas/parentCallId'
        enqueuedTime:
          $ref: '#/components/schemas/enqueuedTime'
        startTime:
          $ref: '#/components/schemas/startTime'
        answerTime:
          $ref: '#/components/schemas/answerTime'
        endTime:
          $ref: '#/components/schemas/endTime'
        tag:
          $ref: '#/components/schemas/tag'
        transferCallerId:
          $ref: '#/components/schemas/transferCallerId'
        transferTo:
          $ref: '#/components/schemas/transferTo'
        cause:
          $ref: '#/components/schemas/cause'
        errorMessage:
          $ref: '#/components/schemas/errorMessage'
        errorId:
          $ref: '#/components/schemas/errorId'
    eventType:
      type: string
      description: >-
        The event type, value can be one of the following: answer,
        bridgeComplete, bridgeTargetComplete, conferenceCreated,
        conferenceRedirect, conferenceMemberJoin, conferenceMemberExit,
        conferenceCompleted, conferenceRecordingAvailable, disconnect, dtmf,
        gather, initiate, machineDetectionComplete, recordingComplete,
        recordingAvailable, redirect, transcriptionAvailable, transferAnswer,
        transferComplete, transferDisconnect.
      example: bridgeComplete
    eventTime:
      type: string
      description: >-
        The approximate UTC date and time when the event was generated by the
        Bandwidth server, in ISO 8601 format. This may not be exactly the time
        of event execution.
    accountId:
      type: string
      description: The user account associated with the call.
      example: '920012'
    applicationId:
      type: string
      description: The id of the application associated with the call.
      example: 04e88489-df02-4e34-a0ee-27a91849555f
    to:
      type: string
      description: >-
        The phone number that received the call, in E.164 format (e.g.
        +15555555555).
      example: '+15555555555'
    from:
      type: string
      description: >-
        The provided identifier of the caller: can be a phone number in E.164
        format (e.g. +15555555555) or one of Private, Restricted, Unavailable,
        or Anonymous.
      example: '+15555555555'
    conferenceId:
      type: string
      description: The unique, Bandwidth-generated ID of the conference that was recorded
      example: conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9
    name:
      type: string
      description: The user-specified name of the conference that was recorded
      example: my-conference-name
    recordingId:
      type: string
      description: The unique ID of this recording
      example: r-fbe05094-9fd2afe9-bf5b-4c68-820a-41a01c1c5833
    duration:
      type: string
      description: The duration of the recording in ISO-8601 format
      example: PT13.67S
    channels:
      type: integer
      format: int32
      description: >-
        Always `1` for conference recordings; multi-channel recordings are not
        supported on conferences.
      example: 1
    digit:
      type: string
      description: The digit collected in the call.
      example: '2'
    digits:
      type: string
      description: >-
        (optional) The digits, letters, and/or symbols entered by the user. The
        string is empty if a timeout occurred before any buttons were pressed.
      example: '123'
    terminatingDigit:
      type: string
      description: >-
        (optional) The digit the user pressed to end the gather. Empty string
        value if no terminating digit was pressed.
      example: '#'
    startTime:
      type: string
      format: date-time
      description: Time the call was started, in ISO 8601 format.
      example: '2022-06-17T22:19:40.375Z'
    enqueuedTime:
      type: string
      format: date-time
      description: >-
        (optional) If call queueing is enabled and this is an outbound call,
        time the call was queued, in ISO 8601 format.
      example: '2022-06-17T22:20:00.000Z'
      nullable: true
    answerTime:
      type: string
      format: date-time
      description: Time the call was answered, in ISO 8601 format.
      example: '2022-06-17T22:20:00.000Z'
      nullable: true
    endTime:
      type: string
      format: date-time
      description: The time that the recording ended in ISO-8601 format
      example: '2022-06-17T22:20:00.000Z'
    status:
      type: string
      description: >-
        The current status of the process. For recording, current possible
        values are 'processing', 'partial', 'complete', 'deleted', and 'error'.
        For transcriptions, current possible values are 'none', 'processing',
        'available', 'error', 'timeout', 'file-size-too-big', and
        'file-size-too-small'. Additional states may be added in the future, so
        your application must be tolerant of unknown values.
      example: completed
    transferCallerId:
      type: string
      description: >-
        The phone number used as the from field of the B-leg call, in E.164
        format (e.g. +15555555555) or one of Restricted, Anonymous, Private, or
        Unavailable.
      example: '+15555555555'
    transferTo:
      type: string
      description: >-
        The phone number used as the to field of the B-leg call, in E.164 format
        (e.g. +15555555555).
      example: +15555555555)
    mediaUrl:
      nullable: true
      type: string
      format: uri
      description: >-
        The URL that can be used to download the recording. Only present if the
        recording is finished and may be downloaded.
      example: >-
        https://voice.bandwidth.com/api/v2/accounts/9900000/conferences/conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9/recordings/r-fbe05094-9fd2afe9-bf5b-4c68-820a-41a01c1c5833/media
    callId:
      type: string
      description: The call id associated with the event.
      example: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    callUrl:
      type: string
      description: The URL of the call associated with the event.
      example: >-
        https://voice.bandwidth.com/api/v2/accounts/9900000/calls/c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    parentCallId:
      type: string
      description: >-
        (optional) If the event is related to the B leg of a <Transfer>, the
        call id of the original call leg that executed the <Transfer>.
        Otherwise, this field will not be present.
      example: c-95ac8d6e-1a31c52e-b38f-4198-93c1-51633ec68f8d
    tag:
      type: string
      description: >-
        (optional) The tag specified on call creation. If no tag was specified
        or it was previously cleared, this field will not be present.
      example: exampleTag
      nullable: true
    cause:
      type: string
      description: >-
        Reason the call failed - hangup, busy, timeout, cancel, rejected,
        callback-error, invalid-bxml, application-error, account-limit,
        node-capacity-exceeded, error, or unknown.
      example: busy
    errorMessage:
      type: string
      description: >-
        Text explaining the reason that caused the call to fail in case of
        errors.
      example: >-
        Call c-2a913f94-6a486f3a-3cae-4034-bcc3-f0c9fa77ca2f is already bridged
        with another call
      nullable: true
    errorId:
      type: string
      description: Bandwidth's internal id that references the error event.
      example: 4642074b-7b58-478b-96e4-3a60955c6765
      nullable: true
    machineDetectionResult:
      type: string
      description: >-
        (optional) if machine detection was requested in sync mode, the result
        will be specified here. Possible values are the same as the async
        counterpart: Machine Detection Complete
      properties:
        value:
          type: string
          description: >-
            Possible values are answering-machine, human, silence, timeout, or
            error.
          example: answering-machine
        duration:
          type: string
          description: The amount of time it took to determine the result.
          example: PT4.9891287S
      nullable: true
    diversion:
      type: object
      properties:
        reason:
          type: string
          description: >-
            The reason for the diversion. Common values: unknown, user-busy,
            no-answer, unavailable, unconditional, time-of-day, do-not-disturb,
            deflection, follow-me, out-of-service, away.
          example: unavailable
        privacy:
          type: string
          description: off or full
          example: 'off'
        screen:
          type: string
          description: >-
            No if the number was provided by the user, yes if the number was
            provided by the network
          example: 'no'
        counter:
          type: string
          description: The number of diversions that have occurred
          example: '2'
        limit:
          type: string
          description: The maximum number of diversions allowed for this session
          example: '3'
        unknown:
          type: string
          description: >-
            The normal list of values is not exhaustive. Your application must
            be tolerant of unlisted keys and unlisted values of those keys.
          example: unknownValue
        origTo:
          type: string
          description: >-
            Always present. Indicates the last telephone number that the call
            was diverted from.
          example: '+15558884444'
    recordingTranscription:
      type: object
      properties:
        text:
          type: string
          description: The transcribed text
          example: Nice talking to you, friend!
        confidence:
          type: number
          format: double
          description: >-
            The confidence on the recognized content, ranging from `0.0` to
            `1.0` with `1.0` being the highest confidence.
          example: 0.9
    stirShaken:
      type: object
      properties:
        verstat:
          type: string
          description: >-
            (optional) The verification status indicating whether the
            verification was successful or not. Possible values are
            TN-Verification-Passed and TN-Verification-Failed.
          example: Tn-Verification-Passed
        attestationIndicator:
          type: string
          description: >-
            (optional) The attestation level verified by Bandwidth. Possible
            values are A (full), B (partial) or C (gateway).
          example: A
        originatingId:
          type: string
          description: (optional) A unique origination identifier.
          example: 99759086-1335-11ed-9bcf-5f7d464e91af
  parameters:
    accountId:
      name: accountId
      in: path
      required: true
      schema:
        type: string
      description: Your Bandwidth Account ID
      example: '9900000'
    callId:
      name: callId
      in: path
      required: true
      schema:
        type: string
      description: Programmable Voice API Call ID
      example: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    recordingId:
      name: recordingId
      in: path
      required: true
      schema:
        type: string
      description: Programmable Voice API Recording ID
      example: r-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    conferenceId:
      name: conferenceId
      in: path
      required: true
      schema:
        type: string
      description: Programmable Voice API Conference ID
      example: conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9
    memberId:
      name: memberId
      in: path
      required: true
      schema:
        type: string
      description: Programmable Voice API Conference Member ID
      example: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    transcriptionId:
      type: string
      description: The transcription id associated with the event.
      example: t-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
    to:
      name: to
      in: query
      required: false
      schema:
        type: string
      description: Filter results by the `to` field.
      example: '%2b19195551234'
    from:
      name: from
      in: query
      required: false
      schema:
        type: string
      description: Filter results by the `from` field.
      example: '%2b19195554321'
    name:
      name: name
      in: query
      required: false
      schema:
        type: string
      description: Filter results by the `name` field.
      example: my-custom-name
    minCreatedTime:
      name: minCreatedTime
      in: query
      required: false
      schema:
        type: string
      description: >-
        Filter results to conferences which have a `createdTime` after or at
        `minCreatedTime` (in ISO8601 format).
      example: '2022-06-21T19:13:21Z'
    maxCreatedTime:
      name: maxCreatedTime
      in: query
      required: false
      schema:
        type: string
      description: >-
        Filter results to conferences which have a `createdTime` before or at
        `maxCreatedTime` (in ISO8601 format).
      example: '2022-06-21T19:13:21Z'
    minStartTime:
      name: minStartTime
      in: query
      required: false
      schema:
        type: string
      description: >-
        Filter results to recordings which have a `startTime` after or including
        `minStartTime` (in ISO8601 format).
      example: '2022-06-21T19:13:21Z'
    maxStartTime:
      name: maxStartTime
      in: query
      required: false
      schema:
        type: string
      description: >-
        Filter results to recordings which have a `startTime` before
        `maxStartTime` (in ISO8601 format).
      example: '2022-06-21T19:13:21Z'
    pageSize:
      name: pageSize
      in: query
      required: false
      schema:
        type: integer
        format: int32
        minimum: 1
        maximum: 1000
        default: 1000
      description: Specifies the max number of conferences that will be returned.
      example: 500
    pageToken:
      name: pageToken
      in: query
      required: false
      schema:
        type: string
      description: >-
        Not intended for explicit use. To use pagination, follow the links in
        the `Link` header of the response, as indicated in the endpoint
        description.
  requestBodies:
    createCallRequest:
      description: JSON object containing information to create an outbound call
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/createCall'
    updateCallRequest:
      description: >-
        JSON object containing information to redirect an existing call to a new
        BXML document
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/updateCall'
    updateCallBxmlRequest:
      required: true
      content:
        application/xml:
          schema:
            type: string
            description: A valid BXML document to replace the call's current BXML.
          examples:
            speakSentence:
              summary: Speak Sentence
              value: |-
                <?xml version=\"1.0\" encoding=\"UTF-8\"?>
                <Bxml>
                  <SpeakSentence>This is a test sentence.</SpeakSentence>
                </Bxml>
            redirectUrl:
              summary: Redirect
              value: |-
                <?xml version=\"1.0\" encoding=\"UTF-8\"?>
                <Bxml>
                  <Redirect redirectUrl="https://test.com" redirectMethod="GET"/>
                </Bxml>
    updateCallRecordingRequest:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/updateCallRecording'
    transcribeRecordingRequest:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/transcribeRecording'
    updateConferenceRequest:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/updateConference'
    updateConferenceBxmlRequest:
      required: true
      content:
        application/xml:
          schema:
            type: string
            description: A valid BXML document to replace the call's current BXML.
          examples:
            stopRecording:
              summary: Stop Recording
              value: |-
                <?xml version="1.0" encoding="UTF-8"?>
                <Bxml>
                    <StopRecording/>
                </Bxml>
    updateConferenceMemberRequest:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/updateConferenceMember'
  responses:
    createCallResponse:
      description: Call Successfully Created
      headers:
        Location:
          description: The URL for further interactions with this call
          schema:
            type: string
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/createCallResponse'
          examples:
            createCall Response:
              $ref: '#/components/examples/createCallResponseExample'
    getCallStateResponse:
      description: Call found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/callState'
    getStatisticsResponse:
      description: Statistics Found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/accountStatistics'
    listCallRecordingsResponse:
      description: Recordings retrieved successfully
      content:
        application/json:
          schema:
            type: array
            items:
              $ref: '#/components/schemas/callRecordingMetadata'
    getCallRecordingResponse:
      description: Recording found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/callRecordingMetadata'
    downloadRecordingMediaResponse:
      description: Media found
      content:
        audio/vnd.wave:
          schema:
            type: string
            format: binary
        audio/mpeg:
          schema:
            type: string
            format: binary
    getRecordingTranscriptionResponse:
      description: Transcription found.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/recordingTranscriptions'
    getCallTranscriptionsResponse:
      description: Transcription found.
      content:
        application/json:
          schema:
            type: array
            items:
              type: string
            description: >-
              The `transcriptionId`s for the transcriptions that were created
              with [StartTranscription](TODO) during this call
            example:
              - t-25ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
              - t-26ac30a3-1331028c-1cb0-3a08-b216-b22865663d86
    getCallTranscriptionResponse:
      description: Transcription found.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/callTranscription'
    listConferencesResponse:
      description: Conferences retrieved successfully
      content:
        application/json:
          schema:
            type: array
            items:
              $ref: '#/components/schemas/conference'
          examples:
            listConferences Response:
              $ref: '#/components/examples/listConferencesResponseExample'
    getConferenceResponse:
      description: Conferences retrieved successfully
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/conference'
    getConferenceMemberResponse:
      description: Conference member found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/conferenceMember'
    listConferenceRecordingsResponse:
      description: Conference recordings retrieved successfully
      content:
        application/json:
          schema:
            type: array
            items:
              $ref: '#/components/schemas/conferenceRecordingMetadata'
    getConferenceRecordingResponse:
      description: Conference recording found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/conferenceRecordingMetadata'
    voiceBadRequestError:
      description: Bad Request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            badRequestErrorExample:
              $ref: '#/components/examples/voiceBadRequestErrorExample'
    voiceUnauthorizedError:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            unauthorizedErrorExample:
              $ref: '#/components/examples/voiceUnauthorizedErrorExample'
    voiceForbiddenError:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            forbiddenErrorExample:
              $ref: '#/components/examples/voiceForbiddenErrorExample'
    voiceNotFoundError:
      description: Not Found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            notFoundErrorExample:
              $ref: '#/components/examples/voiceNotFoundErrorExample'
    voiceNotAllowedError:
      description: Method Not Allowed
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            notAllowedErrorExample:
              $ref: '#/components/examples/voiceNotAllowedErrorExample'
    voiceConflictError:
      description: Conflict
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            conflictErrorExample:
              $ref: '#/components/examples/voiceConflictErrorExample'
    voiceUnsupportedMediaTypeError:
      description: Unsupported Media Type
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            tooManyRequestsErrorExample:
              $ref: '#/components/examples/voiceUnsupportedMediaTypeErrorExample'
    voiceTooManyRequestsError:
      description: Too Many Requests
      headers:
        Retry-After:
          description: When you should try your request again
          schema:
            type: string
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            tooManyRequestsErrorExample:
              $ref: '#/components/examples/voiceTooManyRequestsErrorExample'
    voiceInternalServerError:
      description: Internal Server Error
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/voiceApiError'
          examples:
            internalServerErrorExample:
              $ref: '#/components/examples/voiceInternalServerErrorExample'
  examples:
    createCallResponseExample:
      summary: Example of a createCall Response
      value:
        applicationId: 04e88489-df02-4e34-a0ee-27a91849555f
        accountId: '9900000'
        callId: c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
        to: '+19195551234'
        from: '+19195554312'
        enqueuedTime: '2022-06-16T13:15:07.160Z'
        callUrl: >-
          https://voice.bandwidth.com/api/v2/accounts/9900000/calls/c-15ac29a2-1331029c-2cb0-4a07-b215-b22865662d85
        callTimeout: 30
        callbackTimeout: 15
        tag: My custom tag value
        answerMethod: POST
        answerUrl: https://myServer.com/bandwidth/webhooks/answer
        answerFallbackMethod: POST
        disconnectMethod: POST
        disconnectUrl: https://myServer.com/bandwidth/webhooks/disconnect
        username: mySecretUsername
        password: '*****'
        fallbackUsername: mySecretUsername
        fallbackPassword: '*****'
        priority: 5
    listConferencesResponseExample:
      summary: Example of a listConferences Response
      value:
        - id: conf-fe23a767-a75a5b77-20c5-4cca-b581-cbbf0776eca9
          name: my-conference-name
          createdTime: '2022-06-17T22:19:40.375Z'
          completedTime: '2022-06-17T22:20:00.000Z'
          conferenceEventUrl: https://myServer.com/bandwidth/webhooks/conferenceEvent
          conferenceEventMethod: POST
          tag: my custom tag
    voiceBadRequestErrorExample:
      summary: Example of a Bad Request (400) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceUnauthorizedErrorExample:
      summary: Example of an Unauthorized (401) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceForbiddenErrorExample:
      summary: Example of a Forbidden (403) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceNotFoundErrorExample:
      summary: Example of a Not Found (404) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceNotAllowedErrorExample:
      summary: Example of a Not Allowed (405) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceConflictErrorExample:
      summary: Example of a Conflict (409) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceUnsupportedMediaTypeErrorExample:
      summary: Example of an Unsupported Media Type (415) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceTooManyRequestsErrorExample:
      summary: Example of a Too Many Requests (429) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
    voiceInternalServerErrorExample:
      summary: Example of an Internal Server (500) Error
      value:
        type: validation
        description: 'Invalid answerUrl: only http and https are allowed'
  securitySchemes:
    Basic:
      type: http
      scheme: basic
      description: >-
        Basic authentication is a simple authentication scheme built into the
        HTTP protocol. To use it, send your HTTP requests with an Authorization
        header that contains the word Basic followed by a space and a
        base64-encoded string `username:password`.


        Example: `Authorization: Basic ZGVtbZpwQDU1dzByZA==`
security:
  - Basic: []
tags:
  - name: Calls
  - name: Conferences
  - name: Recordings
  - name: Statistics
  - name: Transcriptions
